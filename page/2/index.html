<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mysql2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/17/mysql2/" class="article-date">
  <time datetime="2016-07-16T16:00:00.000Z" itemprop="datePublished">2016-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/17/mysql2/">rails项目mysql编码由utf8改成utf8mb4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="rails项目mysql编码由utf8改成utf8mb4"><a href="#rails项目mysql编码由utf8改成utf8mb4" class="headerlink" title="rails项目mysql编码由utf8改成utf8mb4"></a>rails项目mysql编码由utf8改成utf8mb4</h2><h3 id="为什么要改编码"><a href="#为什么要改编码" class="headerlink" title="为什么要改编码"></a>为什么要改编码</h3><p>因为utf8编码的mysql不能保存含有4个字节的emoji表情，为了能让客户端支持输入保存emoji表情，数据库必须升级并把编码改成utf8mb4。mysql从5.5.3版本开始支持utf8mb4 字符集。</p>
<p>首先确保mysql server端支持utf8mb4 字符集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW CHAR SET WHERE Charset LIKE &quot;%utf8%&quot;;</div><div class="line">+---------+---------------+--------------------+--------+</div><div class="line">| Charset | Description   | Default collation  | Maxlen |</div><div class="line">+---------+---------------+--------------------+--------+</div><div class="line">| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |</div><div class="line">| utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci |      4 |</div><div class="line">+---------+---------------+--------------------+--------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>然后升级部署应用的服务器上的mysql client版本也得大于5.5.3。我这边是用rpm包单独升级。先卸载掉低版本的rpm包，然后再进行安装。</p>
<ul>
<li>MySQL-client：包含最少的访问mysql服务器所需要的客户端命令。里面包含的是像mysql，mysqladmin这样的工具。</li>
<li>MySQL-devel：包含开发mysql客户端所需要的库。里面没有包含工具，都是包含.a这样的库链接文件</li>
<li>MySQL-server：包含安装mysql所需要的所有工具。里面包含的像是mysqld_safe，mysqld_multi这样的服务器启动安装工具。里面并不包含mysql这样的客户端工具。</li>
<li>Mysql-shared：包含开发mysql客户端所需要的动态链接库。里面并没有工具，都是像libmysqlclient.so*这样的动态库文件。</li>
<li>Mysql-shared-compact：上面动态链接库的以前各个版本的文件。就是进行这个安装会在lib64中放上之前所有release版本的libmysqlclient.so</li>
</ul>
<h3 id="mysql2支持utf8mb4"><a href="#mysql2支持utf8mb4" class="headerlink" title="mysql2支持utf8mb4"></a>mysql2支持utf8mb4</h3><p>当mysql server端和client端都支持utf8mb4之后，我们需要对mysql2<br>进行重新安装。这里需要注意的是，mysql2的版本必须大于0.3.11，不然是不支持utf8mb4字符集的。</p>
<p>进入到应用部署目录，使用bundle exec gem uninstall mysql2，选择当前应用使用的mysql2版本，然后再bundler重新安装mysql2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[bhuser@bhqa current]$ bundle show | grep mysql2</div><div class="line">  * mysql2 (0.4.3)</div><div class="line">[bhuser@bhqa current]$ bundle exec gem uninstall mysql2</div><div class="line">Successfully uninstalled mysql2-0.4.3</div><div class="line">[bhuser@bhqa current]$ bundle</div></pre></td></tr></table></figure></p>
<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>使用下面代码在rails 下进行检验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Mysql2::Client.new(</div><div class="line"> :host =&gt; &apos;host&apos;,</div><div class="line"> :username =&gt; &apos;user&apos;,</div><div class="line"> :password =&gt; &apos;passwd&apos;,</div><div class="line"> :encoding =&gt; &apos;utf8mb4&apos;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2.3.0 :007 &gt; Mysql2::Client.new(</div><div class="line">2.3.0 :008 &gt;      :host =&gt; &apos;x.x.x.x&apos;,</div><div class="line">2.3.0 :009 &gt;      :username =&gt; &apos;user&apos;,</div><div class="line">2.3.0 :010 &gt;      :password =&gt; &apos;passwd&apos;,</div><div class="line">2.3.0 :011 &gt;      :encoding =&gt; &apos;utf8mb4&apos;</div><div class="line">2.3.0 :012?&gt;   )</div><div class="line"> =&gt; #&lt;Mysql2::Client:0x000000040c17b0 @read_timeout=nil, @query_options=&#123;:as=&gt;:hash, :async=&gt;false, :cast_booleans=&gt;false, :symbolize_keys=&gt;false, :database_timezone=&gt;:local, :application_timezone=&gt;nil, :cache_rows=&gt;true, :connect_flags=&gt;2147525125, :cast=&gt;true, :default_file=&gt;nil, :default_group=&gt;nil, :host=&gt;&quot;host&quot;, :username=&gt;&quot;user&quot;, :password=&gt;&quot;passwd&quot;, :encoding=&gt;&quot;utf8mb4&quot;&#125;&gt; </div><div class="line">2.3.0 :013 &gt;</div></pre></td></tr></table></figure>
<p>上面结果表示成功升级<br>下面的提示是没有升级mysql2的错误信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Character set &apos;utf8mb4&apos; is not a compiled character set and is not specified in the &apos;/path/mysql/charsets/Index.xml&apos; file</div><div class="line">rake aborted!</div><div class="line">Mysql2::Error: Can&apos;t initialize character set utf8mb4 (path: /path/mysql/charsets/)</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/17/mysql2/" data-id="ciu2e80fi000i7rhp9r4ybcmo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-monit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/08/monit/" class="article-date">
  <time datetime="2016-07-07T16:00:00.000Z" itemprop="datePublished">2016-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/08/monit/">Monit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Monit"><a href="#Monit" class="headerlink" title="Monit"></a>Monit</h2><p><a href="https://mmonit.com/monit/dist/monit-5.18.tar.gz" target="_blank" rel="external">下载地址</a></p>
<h4 id="什么是monit"><a href="#什么是monit" class="headerlink" title="什么是monit"></a>什么是monit</h4><p>monit是用来管理unix系统上面的进程、程序、文件、目录以及文件系统的实用工具。<br>monit能进行自动修复功能，比如对于没有运行的进程进行start操作，对于没有响应的进程进行restart操作，对于暂用过多资源的进程进行stop操作等。<br>monit还能监控文件、文件夹以及文件系统的一些变化。比如时间戳的变化、checksun的变化、以及文件大小的变化。<br>monit可以执行各种TCP/IP的网络检查。</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>monit的监控主要通过配置文件monitrc（5.1.4以前叫monit.conf），默认会读取~/.monitrc，如果没有，则会去读取/etc/monitrc，如果都没找到，就去读取~/monitrc。<br>当然，我们也可以在运行的时候指定配置文件地址<br> 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monit -c /var/monit/monitrc</div></pre></td></tr></table></figure></p>
<p>配置文件分为Global section和Services</p>
<h3 id="Global-section"><a href="#Global-section" class="headerlink" title="Global section"></a>Global section</h3><p>先来看一下Global section需要设置的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">set daemon  30  # 设置monit守护进程多长时间运行一次</div><div class="line"></div><div class="line">set logfile /var/monit/monit.log #设置日志输出地址，默认输出到系统日志里面</div><div class="line"></div><div class="line">set mailserver  localhost #设置邮件服务器地址</div><div class="line"></div><div class="line">set eventqueue</div><div class="line">    basedir /var/monit</div><div class="line">    slots 100    #当邮件服务器出问题了，可以通过设置eventqueue，让事件存放在basdir里面，slots表示队列最多限制</div><div class="line">    </div><div class="line">set mail-format &#123; from: monit@foo.bar &#125; #设置邮件格式 from地址</div><div class="line"></div><div class="line">set alert 442103349@qq.com   #报警接收地址，可设置多个；monit默认只发送一次失败邮件，如果想要发送多个可以加上参数“set alert 442103349@qq.com with reminder on 5 cycles”这样会5个失败周期发送一次报警；如果对于某些监控不需要报警可以这样</div><div class="line">check process p1 with pidfile /var/run/p1.pid </div><div class="line">noalert 442103349@qq.com</div><div class="line"></div><div class="line">set httpd port 2812 #开始http监控服务，可以通过web页面进行监控</div><div class="line">    use address localhost  #如果不注释这一条，只能本地访问http服务，所以一般注释掉</div><div class="line">    allow 127.0.0.1</div><div class="line">    allow 192.168.1.0/24 </div><div class="line">    allow admin:monit  #web页面登录帐号</div><div class="line">    allow ggyy:gongyang read-only #设置帐号只有查看权限（很重要）</div></pre></td></tr></table></figure></p>
<h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>Services 主要设置具体监控项目<br>每个服务可以有相关联的启动、停止和重启方法，Monit可以使用它来执行服务行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check process sendmail with pidfile /var/run/sendmail.pid</div><div class="line">   start program = &quot;/etc/init.d/sendmail start&quot; with timeout 60 seconds</div><div class="line">   stop program = &quot;/etc/init.d/sendmail stop&quot;</div></pre></td></tr></table></figure></p>
<p>monit是通过set daemon设定的固定周期检查，我们也可以设定几个周期检查一次<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check process nginx with pidfile /var/run/nginx.pid</div><div class="line">       every 2 cycles</div><div class="line">设定两个周期检查一次</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">check program checkOracleDatabase</div><div class="line">        with path /var/monit/programs/checkoracle.pl</div><div class="line">       every &quot;* 8-19 * * 1-5&quot;</div><div class="line">每周1-5天的8-19点做检查，设置时间方法和crontab一样</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check process mysqld with pidfile /var/run/mysqld.pid</div><div class="line">       not every &quot;* 0-3 * * 0&quot;</div><div class="line">星期天的凌晨0-3点不执行检查</div></pre></td></tr></table></figure>
<h4 id="service-restart-limit"><a href="#service-restart-limit" class="headerlink" title="service restart limit"></a>service restart limit</h4><p>monit对于restart一些限制机制<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if 2 restarts within 3 cycles then unmonitor</div><div class="line">如果三个周期内重启了两次，就不监控了</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if 5 restarts within 5 cycles then exec &quot;/tmp/1.sh&quot;</div><div class="line"> 5个周期重启了5次，就执行某个脚本</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if 7 restarts within 10 cycles then stop</div><div class="line">10个周期重启了7次，就直接stop</div></pre></td></tr></table></figure>
<h4 id="monit-tests"><a href="#monit-tests" class="headerlink" title="monit tests"></a>monit tests</h4><p>语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IF &lt;test&gt; THEN &lt;action&gt; [ELSE IF SUCCEEDED THEN &lt;action&gt;]</div></pre></td></tr></table></figure></p>
<p>action有以下几种</p>
<ul>
<li>ALERT</li>
<li>start</li>
<li>stop</li>
<li>restart</li>
<li>exec</li>
<li>UNMONITOR</li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if failed</div><div class="line">    port 80</div><div class="line">    for 3 cycles</div><div class="line"> then alert</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check filesystem rootfs with path /dev/hda1</div><div class="line">  if space usage &gt; 80% for 5 times within 15 cycles then alert</div><div class="line">  if space usage &gt; 90% for 5 cycles then exec &apos;/try/to/free/the/space&apos;</div></pre></td></tr></table></figure>
<p><strong>是否存在监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IF [DOES] NOT EXIST THEN &lt;action&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file with path /cifs/mydata</div><div class="line">       if does not exist then exec &quot;/usr/bin/mount_cifs.sh&quot;</div></pre></td></tr></table></figure>
<p><strong>使用资源监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if cpu is greater than 50% for 5 cycles then restart</div></pre></td></tr></table></figure></p>
<p><strong>checksum 监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">check file passwd with path /etc/password</div><div class="line">if failed</div><div class="line">    checksum expect 8f7f419955cefa0b33a2ba316cba3659</div><div class="line"> then alert</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file apache_conf with path /etc/apache/httpd.conf</div><div class="line">     if changed checksum then alert</div></pre></td></tr></table></figure>
<p><strong>时间戳监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file passwd with path /etc/password</div><div class="line">   if changed timestamp then alert</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file passwd with path /etc/password</div><div class="line">   if changed timestamp &gt; 2 MINUTE then alert</div></pre></td></tr></table></figure>
<p><strong>文件大小监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file mydb with path /data/mydatabase.db</div><div class="line">      if size &gt; 1 GB then alert</div></pre></td></tr></table></figure></p>
<p><strong>文件内容监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check file syslog with path /var/log/syslog</div><div class="line">        ignore content = &quot;^monit&quot;</div><div class="line">        if content = &quot;^mrcoffee&quot; then alert</div></pre></td></tr></table></figure></p>
<p><strong>磁盘空间监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check filesystem rootfs with path /</div><div class="line">       if space usage &gt; 90% then alert</div></pre></td></tr></table></figure></p>
<p><strong>inode 监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check filesystem rootfs with path /</div><div class="line">       if inode usage &gt; 90% then alert</div></pre></td></tr></table></figure></p>
<p><strong>权限监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file shadow with path /etc/shadow</div><div class="line">      if failed permission 0640 then alert</div></pre></td></tr></table></figure></p>
<p><strong>uid gid  pid ppid监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file shadow with path /etc/shadow</div><div class="line">      if failed uid root then alert</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check file shadow with path /etc/shadow</div><div class="line">       if failed gid shadow then alert</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check process sshd with pidfile /var/run/sshd.pid</div><div class="line">       if changed pid then alert</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check process myproc with pidfile /var/run/myproc.pid</div><div class="line">       if changed ppid then exec &quot;/my/script&quot;</div></pre></td></tr></table></figure>
<p><strong>运行时间监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">check process myapp with pidfile /var/run/myapp.pid</div><div class="line">    start program = &quot;/etc/init.d/myapp start&quot;</div><div class="line">    stop program = &quot;/etc/init.d/myapp stop&quot;</div><div class="line">    if uptime &gt; 3 days then restart</div></pre></td></tr></table></figure></p>
<p><strong>网络链接状态监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check network eth0 with interface eth0</div><div class="line">      if failed link then alert</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">check network eth0 with interface eth0</div><div class="line">       start program = &apos;/sbin/ipup eth0&apos;</div><div class="line">       stop program = &apos;/sbin/ipdown eth0&apos;</div><div class="line">       if failed link then restart</div></pre></td></tr></table></figure>
<p><strong>网络带宽监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">check network eth0 with interface eth0</div><div class="line">       if upload &gt; 500 kB/s then alert</div><div class="line">       if total download &gt; 1 GB in last 2 hours then alert</div><div class="line">       if total download &gt; 10 GB in last day then alert</div></pre></td></tr></table></figure></p>
<p><strong>网络数据包监控</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">check network eth0 with interface eth0</div><div class="line">      if upload &gt; 1000 packets/s then alert</div><div class="line">      if total upload &gt; 900000 packets in last hour then alert</div></pre></td></tr></table></figure></p>
<p>配置完成之后使用-t参数检查一遍语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monit -t</div></pre></td></tr></table></figure></p>
<p>启动<br>直接运行monit即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monit</div></pre></td></tr></table></figure></p>
<p>可以通过status参数查看监控项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monit status</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/08/monit/" data-id="ciu2e80ff000h7rhpdblif67r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sneakers" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/30/sneakers/" class="article-date">
  <time datetime="2016-06-29T16:00:00.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/sneakers/">Use capistrano sequence restart service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于capistrano的发布是一个并行的处理，所以在restart某个服务进程的时候，也是同时进行的。从某种程度上来说，在restart的过程当中（先stop，然后start），服务会存在短时间内不可用的状态。当然，如果服务进程支持平滑启动，就不存在上述的问题，像unicorn的启动，就是一种平滑启动方式。<br><strong>tips</strong><br>平滑启动，大家可以简单的理解为，在restart过程中，先启动一组新的进程用来接受新的请求，老的进程停止接收新的请求，然后老的进程处理完当前的请求自动退出。</p>
<p>目前我们在发布过程中，除了unicorn是平滑启动之外，sidekiq、sneaker等服务都是先stop、然后再start，那么这个过程当中，就会存在一段时间服务不可能。由于sidekiq是用来处理异步任务的，他的数据都是从redis里面读取，短时间的不可用还是可以接受。但是sneaker不行（原因是各应用之间的依赖），所以我们需要在发布过程中，修改sneaker的启动方式，先restart其中一台server的sneaker进程，然后在接着对另外一台server进行restart（当然，前提是至少你要在两台服务器上运行了sneaker work）</p>
<p>我们要修改sneaker的启动过程，前提是要知道deploy的哪个步骤会去调用sneaker的stop、start以及restart task。</p>
<p>我们先来了解一下运行cap production deploy会调用那些tasks，以及执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">deploy:starting    - start a deployment, make sure everything is ready</div><div class="line">deploy:started     - started hook (for custom tasks)</div><div class="line">deploy:updating    - update server(s) with a new release</div><div class="line">deploy:updated     - updated hook</div><div class="line">deploy:publishing  - publish the new release</div><div class="line">deploy:published   - published hook</div><div class="line">deploy:finishing   - finish the deployment, clean up everything</div><div class="line">deploy:finished    - finished hook</div></pre></td></tr></table></figure>
<p>cap production deploy:rollback 调用的tasks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">deploy:starting</div><div class="line">deploy:started</div><div class="line">deploy:reverting           - revert server(s) to previous release</div><div class="line">deploy:reverted            - reverted hook</div><div class="line">deploy:publishing</div><div class="line">deploy:published</div><div class="line">deploy:finishing_rollback  - finish the rollback, clean up everything</div><div class="line">deploy:finished</div></pre></td></tr></table></figure>
<p>查看sneakers.rb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">after :publishing, :restart_sneakers do</div><div class="line">    invoke &apos;sneakers:restart&apos; if fetch(:sneakers_default_hooks)</div><div class="line">  end</div></pre></td></tr></table></figure></p>
<p>从上面代码我们可以分析得出，在deploy:publishing之后会调用sneakers:restart。然后我们在搜一下有没有在deploy过程中调用sneakers:stop之类的，因为如果有在sneakers:restart之前就是执行了sneakers:stop，那其实整个服务就停止了，哪怕做到分台停止也没有任何意义了，如果有的话，那么就需要注释掉，因为在restart过程中我们会先stop，然后start。</p>
<p>然后我们来看一下sneakers:restart会做哪些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">desc &apos;Restart sneakers&apos;</div><div class="line">  task :restart do</div><div class="line">    invoke &apos;sneakers:stop&apos;</div><div class="line">    invoke &apos;sneakers:start&apos;</div><div class="line">  end</div></pre></td></tr></table></figure></p>
<p>是不是一脸懵逼，没错，就是这么简单；然后我就直接修改这个task，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">desc &apos;Restart sneakers&apos;</div><div class="line">  task :restart do</div><div class="line">    on roles(:sneakers_server), in: :sequence do</div><div class="line">    invoke &apos;sneakers:stop&apos;</div><div class="line">    sleep 2</div><div class="line">    invoke &apos;sneakers:start&apos;</div><div class="line">  end</div><div class="line"> end</div></pre></td></tr></table></figure></p>
<p>上面的意思就是sneakers_server定义的服务器按照顺序执行stop、start。表面上看上去问题就这样解决了，如果有多台 sneakers 服务器，一台一台执行stop、start。然后并没有这么简单，部署的时候发现，stop的时候，所有的sneaker服务器还是同时停止work。这个时候，我们就得看sneakers:stop这个task究竟干了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">desc &apos;Stop sneakers&apos;</div><div class="line"> task :stop do</div><div class="line">   on roles fetch(:sneakers_role) do</div><div class="line">     if test(&quot;[ -d #&#123;current_path&#125; ]&quot;)</div><div class="line">       for_each_sneakers_process(true) do |pid_file, idx|</div><div class="line">         if sneakers_pid_process_exists?(pid_file)</div><div class="line">           stop_sneakers(pid_file)</div><div class="line">         end</div><div class="line">       end</div><div class="line">     end</div><div class="line">   end</div><div class="line"> end</div></pre></td></tr></table></figure></p>
<p>又是一脸懵逼，原来在stop的时候fetch(:sneakers_role)所有的sneaker服务器，执行invoke ‘sneakers:stop’的时候，必然会停掉所有sneaker work。看来只能重构restart这个task了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">desc &apos;Restart sneakers&apos;</div><div class="line"> task :restart do</div><div class="line">   on roles(:sneakers_server), in: :sequence  do</div><div class="line">   if test(&quot;[ -d #&#123;current_path&#125; ]&quot;)</div><div class="line">       for_each_sneakers_process(true) do |pid_file, idx|</div><div class="line">         if sneakers_pid_process_exists?(pid_file)</div><div class="line">           stop_sneakers(pid_file)</div><div class="line">       end</div><div class="line">     end</div><div class="line">   end  </div><div class="line">   sleep 3</div><div class="line">   for_each_sneakers_process do |pid_file, idx|</div><div class="line">       start_sneakers(pid_file, idx) unless sneakers_pid_process_exists?(pid_file)</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>虽说是重构，实际上就是把stop和start task里面的代码整合到一起，中间sleep 3秒的作用就是：因为stop是使用kill -TERM终止信号，如果进程很繁忙的时候，发送该信号，需要等待几秒钟进程才会退出，然后才能执行start操作。不然进程还没有退出就开始进行start操作，sneaker是不会执行start task，导致服务重启失败</p>
<p>最后测试，达到预期效果，了解了如何修改sneaker重启过程，同样的像sidekiq，unicorn也是类似的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/30/sneakers/" data-id="ciu2e80gf000s7rhpa064yida" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-awk" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/26/awk/" class="article-date">
  <time datetime="2016-06-25T16:00:00.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/awk/">linux实用工具之--AWK</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>AWK是由 Alfred Aho、Peter Weinberger、Brian Kernighan三人创造出来的一款非常棒的数据处理工具。<br>相比于sed作用于一整行的数据处理方式，awk则是将一行数据分成数个“字段”来处理，而默认的字段分隔符为空格键或[tab]键。</p>
<p><strong>使用语法：</strong></p>
<blockquote>
<p>awk ‘条件类型1{动作1} 条件类型2{动作2}…’ filename</p>
</blockquote>
<p><strong>实例 1</strong><br>使用last查看最后10条登录记录，并只查看登录用户名和IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ last -n10 |awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos;</div><div class="line">ggyy	192.168.168.1</div><div class="line">reboot	boot</div><div class="line">ggyy	192.168.168.1</div><div class="line">ggyy	192.168.168.1</div><div class="line">reboot	boot</div><div class="line">ggyy	192.168.168.1</div><div class="line">reboot	boot</div><div class="line">ggyy	192.168.168.1</div><div class="line">ggyy	192.168.168.1</div><div class="line">reboot	boot</div></pre></td></tr></table></figure></p>
<p>print是awk最常使用的动作，通过print的功能将字段数据列出来。其中的<figure class="highlight plain"><figcaption><span>的意思是```$1``` 和 ```$3``` 之间用[tab]隔开。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">awk的处理数据的流程如下；</div><div class="line">1、读入第一行，并将第一行的数据填入 ```$0,$1,$2``` 等变量中；</div><div class="line">2、依据条件类型的限制，判断是否需要进行后面的动作；</div><div class="line">3、做完所有的动作与条件类型；</div><div class="line">4、若还有后续的数据，则重复上面的1-3的步骤，直到所有的数据都读完为止。</div><div class="line"></div><div class="line">通过上面的讲叙，我们知道awk是以行为一次的处理单位，以字段为最小的处理单位。那么awk怎么知道到底这个数据有几行几列？我们来了解一下awk内置的变量</div><div class="line">&gt; NF：每一行（$0）拥有的字段总数</div><div class="line">&gt; NR：目前awk所处理的是“第几行”数据</div><div class="line">&gt; FS：目前的分隔字符，默认是空格键</div><div class="line"></div><div class="line">**tips：**</div><div class="line">由于单引号是awk的固定用法，awk后续的所有动作都是以单引号括住的，所以使用print打印时，非变量的文字部分，包括 \t ，都需要使用双引号括起来。</div><div class="line"></div><div class="line">#### AWK的逻辑运算符</div><div class="line">逻辑运算符是作用在条件里面，awk主要有的逻辑运算符有：</div></pre></td></tr></table></figure></p>
<blockquote>
<p>大于<br> &lt; 小于<br>= 大于等于<br> &lt;= 小于等于<br> == 等于<br> != 不等于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">**实例2**</div><div class="line">查看/etc/password里面UID小于5，且只显示用户名和UID</div></pre></td></tr></table></figure></p>
</blockquote>
<p>[ggyy@gy-vm02 ~]$ awk ‘{FS=”:”}$3&lt;5{print $1 “\t” $3}’ /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>bin    1<br>daemon    2<br>adm    3<br>lp    4<br>[ggyy@gy-vm02 ~]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们可以看到第一行数据并没有按照我们的想法输出，这是因为我们定义的```FS=“:”``` 动作要从第二行才开始生效，第一行还是按照原来的方式输出了，所以这个时候需要加上BEGIN关键字：</div></pre></td></tr></table></figure></p>
<p>[ggyy@gy-vm02 ~]$ awk ‘BEGIN{FS=”:”}$3&lt;5{print $1 “\t” $3}’ /etc/passwd<br>root    0<br>bin    1<br>daemon    2<br>adm    3<br>lp    4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**实例3**</div><div class="line">awk还可以像grep去匹配数据</div></pre></td></tr></table></figure></p>
<p>[ggyy@gy-vm02 ~]$ awk ‘$6 ~ /FIN|TIME/ {print NR,$4,$5,$6}’ 1.txt<br>5 coolshell.cn:80 124.205.5.146:18245 TIME_WAIT<br>6 coolshell.cn:80 61.140.101.185:37538 FIN_WAIT2<br>9 coolshell.cn:80 116.234.127.77:11502 FIN_WAIT2<br>11 coolshell.cn:80 183.60.215.36:36970 TIME_WAIT<br>13 coolshell.cn:80 124.152.181.209:26825 FIN_WAIT1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">还可以取反</div></pre></td></tr></table></figure></p>
<p>[ggyy@gy-vm02 ~]$ awk ‘$6 !~ /FIN|TIME/ {print NR,$4,$5,$6}’ 1.txt<br>1 Local-Address Foreign-Address State<br>2 0.0.0.0:3306 0.0.0.0:<em> LISTEN<br>3 0.0.0.0:80 0.0.0.0:</em> LISTEN<br>4 127.0.0.1:9000 0.0.0.0:<em> LISTEN<br>7 coolshell.cn:80 110.194.134.189:103 ESTABLISHED<br>8 coolshell.cn:80 123.169.124.111:49809 ESTABLISHED<br>10 coolshell.cn:80 123.169.124.111:49829 ESTABLISHED<br>12 coolshell.cn:80 61.148.242.38:30901 ESTABLISHED<br>14 :::22 :::</em> LISTEN<br>```</p>
<p>除此之外，AWK还有很多高级语法，这里就不详细讲叙了，了解基础就可以应付大部分的操作了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/26/awk/" data-id="ciu2e80em00017rhp4zr84pjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-open_falcon" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/19/open_falcon/" class="article-date">
  <time datetime="2016-06-18T16:00:00.000Z" itemprop="datePublished">2016-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/19/open_falcon/">小米开源监控open-falcon</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="小米开源监控open-falcon"><a href="#小米开源监控open-falcon" class="headerlink" title="小米开源监控open-falcon"></a>小米开源监控open-falcon</h2><p>最近一段时间都在研究小米开源的监控项目open-falcon，为什么要研究它，当然是要用到它才回去学习它。做为一款国内开源的监控项目，在某些功能细节还有待完善，但还是有其自己特点所在。</p>
<p>具体安装我这里就不啰嗦了，详细请参考<a href="http://book.open-falcon.org/zh/index.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p>了解一款软件，我们先从它的体系架构入手，下面这个就是open-falcon的体积结构图<br><img src="http://image20.it168.com/201510_0x0/2342/78d0080e1afb0674.png" alt=""></p>
<ul>
<li>falcon-agent：agent用于采集机器负载监控指标，自动收集200多项指标，每隔60秒push到tranfer组件，只要安装了agent，就会自动采集数据，主动上报，不需要在server端做任何配置。</li>
<li>transfer：transfer是数据转发服务，它接收agent上传的数据，然后通过一次性哈希对数据分片，然后将分片后的数据push到judge和graph组件。</li>
<li>judge：judge会对transfer上传上来的数据都会进行告警判断，如果数据量比较大，一台机器肯定抗不住，所以在transfer层就对数据进行了分片，后端配置多个judge，每个judge处理一小部分数据。</li>
<li>alarm ：judge产生的报警event会存放到redis队列，alarm会去redis队列里面拿数据，并选择告警方式。alarm并不自己发送邮件短信，是由sender模块来完成的。</li>
<li>graph ：graph接收transfer上传上来的数据，做为绘图数据的组件，参考rrdtool的理念，在数据每次存入的时候，会自动进行采样、归档。</li>
<li>query ：query组件，提供统一的绘图数据查询入口。query组件接收查询请求，根据一致性哈希算法去相应的graph实例查询不同metric的数据，然后汇总拿到的数据，最后统一返回给用户。</li>
<li>dashboard ：dashboard是面向用户的查询界面。在这里，用户可以看到push到graph中的所有数据，并查看其趋势图。</li>
<li>portal ：这个是用来配置报警策略的，数据存在mysql里面</li>
<li>Heartbeat Server： 心跳服务器，公司所有agent都会连到HBS，每分钟发一次心跳请求。</li>
</ul>
<p>以上这些，就是open-falcon的主要模块，了解了这些模块，部署起来就很方便了。</p>
<p><strong>重点</strong><br>我们知道portal用来配置监控策略的，但是portal数据库中有一个host表，用来记录公司所有机器信息，这些信息都是HBS在维护。agent在连接HBS的同时，会把hostname、ip、agent version、plugin version等信息告诉HBS，HBS负责更新host表。还有一点就是，agent虽然能收集200多项指标，但是类似与端口进程监控，agent不可能全部上传，这也不太现实。open-falcon换了另外一种思路，只对portal配置了的端口进行数据上报。那agent如何知道portal里面配置了哪些监控端口了。还是HBS，HBS会去读portal数据库，然后告诉agent。</p>
<p>除了falcon-agent采集的数据可以push到监控系统，我们还可以自己自定义的一些数据指标，也可以push到open-falcon中。agent提供了一个http接口/v1/push用于接收用户手工push的一些数据，然后通过长连接迅速转发给Transfer。</p>
<p><strong>特点</strong><br>1、自动发现，支持falcon-agent、snmp、支持用户主动push、用户自定义插件支持<br>2、支持每个周期上亿次的数据采集、告警判定、历史数据存储和查询<br>3、高效的portal、支持策略模板、模板继承和覆盖、多种告警方式、支持callback调用<br>4、单机支撑200万metric的上报、归档、存储<br>5、采用rrdtool的数据归档策略，秒级返回上百个metric一年的历史数据<br>6、多维度的数据展示，用户自定义Screen<br>7、通过各种插件目前支持Linux、Windows、Mysql、Redis、Memache、RabbitMQ和交换机监控。</p>
<p><strong>缺点</strong><br>由于发布时间较短，很多基础的服务监控插件(如Tomcat、apache等)还不支持，很多功能还在不断完善中，另外由于缺少专门的支持，虽然有开放社区，但是解决问题的效率相对较低。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/19/open_falcon/" data-id="ciu2e80fu000m7rhpqqjqazpj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx_upgrade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/29/nginx_upgrade/" class="article-date">
  <time datetime="2016-05-28T16:00:00.000Z" itemprop="datePublished">2016-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/29/nginx_upgrade/">nginx 平滑升级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="nginx-平滑升级"><a href="#nginx-平滑升级" class="headerlink" title="nginx 平滑升级"></a>nginx 平滑升级</h2><p>由于公司需要使用HTTP/2，以及IPv6等新特性，需要在nginx层添加相对应的模块。我们使用的是淘宝开源的tengine，需要下载最新的版本才能支持HTTP/2，<a href="http://tengine.taobao.org/download_cn.html" target="_blank" rel="external">下载地址</a>。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>升级之前，我们还是先把配置文件copy一份。然后使用nginx -V查看nginx的版本和编译了哪些模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@bhqa nginx]# /usr/local/nginx/sbin/nginx -V</div><div class="line">Tengine version: Tengine/2.1.0 (nginx/1.6.2)</div><div class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) </div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --with-http_ssl_module --with-http_gzip_static_module --with-http_stub_status_module</div></pre></td></tr></table></figure></p>
<p>解压下载的新版本，进入到解压后的目录，编译安装新版本。这里需要注意的一点是，我们原来在编译的时候，使用的默认安装路径，没有特别指定安装路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@bhqa tengine-2.1.2]# ./configure --with-http_ssl_module --with-http_gzip_static_module --with-http_stub_status_module --with-ipv6 --with-http_v2_module &amp;&amp; make &amp;&amp; make install</div></pre></td></tr></table></figure></p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>首先检查新的nginx二进制文件是否可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[bhuser@bhqa conf]$ sudo /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</div><div class="line">the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</div><div class="line">configuration file /usr/local/nginx/conf/nginx.conf test is successful</div></pre></td></tr></table></figure></p>
<p>接下来我们使用kill -USR2给当前的nginx主进程发送一个信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</div></pre></td></tr></table></figure></p>
<p>我们来看下此时的nginx进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@bhqa tengine-2.1.2]# ps aux | grep nginx</div><div class="line">root      2073  0.0  0.0  71056  2056 ?        Ss   May19   0:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</div><div class="line">nobody    2076  0.0  0.0 101300  9396 ?        S    May19   7:07 nginx: worker process                                          </div><div class="line">nobody    2077  0.0  0.1 101756 10972 ?        S    May19   7:15 nginx: worker process                                          </div><div class="line">root     12857  0.6  0.0  71640  7696 ?        S    15:49   0:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</div><div class="line">nobody   12858  0.4  0.3  99288 32396 ?        S    15:49   0:00 nginx: worker process                                          </div><div class="line">nobody   12859  0.2  0.3  99288 32396 ?        S    15:49   0:00 nginx: worker process</div></pre></td></tr></table></figure></p>
<p>此时的新老进程会同时存在，都会接受并处理请求，并且原来/usr/local/nginx/logs/nginx.pid会改为/usr/local/nginx/logs/nginx.pid.oldbin。</p>
<p>这个时候，我们可以使用kill -WINCH这个信号来让老的worker进程不再接受新的请求并退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill -WINCH `cat /usr/local/nginx/logs/nginx.pid.oldbin`</div></pre></td></tr></table></figure></p>
<p>此时我们再来看下这个时候nginx进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@bhqa tengine-2.1.2]# ps aux | grep nginx</div><div class="line">root      2073  0.0  0.0  71056  2084 ?        Ss   May19   0:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</div><div class="line">root     12857  0.0  0.0  71640  7696 ?        S    15:49   0:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</div><div class="line">nobody   12858  0.2  0.3  99288 33780 ?        S    15:49   0:00 nginx: worker process                                          </div><div class="line">nobody   12859  0.2  0.3  99288 33820 ?        S    15:49   0:00 nginx: worker process</div></pre></td></tr></table></figure></p>
<p>我们发现老的worker都退出了，只剩下一个master进程。此时如果我们由于其他原因，不想升级到新版本了，还是可以回退到旧版本的，具体步骤如下：</p>
<ul>
<li>发送HUP 信号给旧的master process；</li>
<li>发送QUIT 信号给新的master process，从容关闭它的worker processes；</li>
<li>发送TERM 信号给新的master process, 强迫关闭；</li>
<li>如果一些原因新的worker process没有关闭，发送KILL 信号给它；</li>
<li>新的master process 关闭后，旧的master process 删除.oldbin后缀，这样就恢复到升级前的状态了。</li>
</ul>
<p>如果我们不需要回退，那现在就剩下最后一步升级就完成了，使用kill -QUIT信号，让老的master进程也退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</div></pre></td></tr></table></figure></p>
<p>到此，整个升级我们就完成了，我们来看下当前的nginx版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@bhqa tengine-2.1.2]# /usr/local/nginx/sbin/nginx -V</div><div class="line">Tengine version: Tengine/2.1.2 (nginx/1.6.2)</div><div class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) </div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --with-http_ssl_module --with-http_gzip_static_module --with-http_stub_status_module --with-ipv6 --with-http_v2_module</div></pre></td></tr></table></figure></p>
<p>版本已是最新的2.1.2，IPv6和HTTP/2相应的模块也编译进去了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/29/nginx_upgrade/" data-id="ciu2e80fm000k7rhpd55yqaks" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-route" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/29/route/" class="article-date">
  <time datetime="2016-05-28T16:00:00.000Z" itemprop="datePublished">2016-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/29/route/">linux 路由表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道，同一个局域网里面，我们可以通过ip广播的方式来实现数据传递的目的。但是不是同一个局域网内的数据传递，就需要路由器来实现了。</p>
<p>假设我们一台主机A（192.168.1.100/24），主机B（192.168.2.100/24），它们是不同的网段，所以不能直接通讯。那A是怎么知道B不是同一个网段了，当然是通过Net_ID（网络号码）来区分的。一个完整的IP是由Net_ID（网络号码）和Host_ID（主机号码）组成，Net_ID是用来区分是不是同一个网段，而Host_ID是用来区分不同主机的。一台主机需要发送数据，主要是通过参考本机的路由表来决定。</p>
<h3 id="查看主机路由表"><a href="#查看主机路由表" class="headerlink" title="查看主机路由表"></a>查看主机路由表</h3><p>在linux系统下面，我们可以通过route这条命令查看一下本机的路由信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# route </div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">192.168.1.0     *               255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.168.0   *               255.255.255.0   U     0      0        0 eth1</div><div class="line">link-local      *               255.255.0.0     U     1002   0        0 eth0</div><div class="line">link-local      *               255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.17.0.0      *               255.255.0.0     U     0      0        0 docker0</div><div class="line">default         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure></p>
<p>一般我们会加上参数-n，将主机名以 IP 的方式显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# route -n</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.168.0   0.0.0.0         255.255.255.0   U     0      0        0 eth1</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div><div class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure></p>
<p>上面输出的数据共有八个字段，你需要注意的有几个地方：<br> Destination ：其实就是 Network 的意思；<br> Gateway     ：就是该接口的 Gateway 那个 IP ，若为 0.0.0.0 表示不需要额外的 IP；<br> Genmask     ：就是 Netmask 啦，与 Destination 组合成为一部主机或网域；<br> Flags       ：共有多个标志可以来表示该网域或主机代表的意义：</p>
<ul>
<li>U：代表该路由可用；</li>
<li>G：代表该网域需要经由 Gateway 来帮忙转递；</li>
<li>H：代表该行路由为一部主机，而非一整个网域；</li>
</ul>
<p>Iface       ：就是 Interface (接口) 的意思。</p>
<p>上面的信息就是我本机的路由表信息，如果我们有个数据包目的IP是192.168.1.0/24网段的，那么就会选择第一条路由，并且通过eth0这个接口发送出去。同理，如果我们有个数据包目的IP是192.168.168.0/24网段的，那么就会选择第二条路由，并且通过eth1这个接口发送出去。如果目的IP不在路由表的规则里面，那么就会将数据包传送到Flags带有G的那条路由规则里面，也就是192.168.1.1这个Gateway。</p>
<h3 id="添加路由信息"><a href="#添加路由信息" class="headerlink" title="添加路由信息"></a>添加路由信息</h3><p>上面，我们通过route这条命令，可以看到本机的路由信息，那么这些信息是如何产生的了？<br>首先，192.168.1.0/24和192.168.168.0/24这两条路由信息的存在是因为我们本机有192.168.1.109和192.168.168.11这两个ip。也就是说，主机上面有几个网络接口，就会存在几条对应的路由信息。下面我来添加一个虚拟接口来验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# ifconfig eth0:0 192.168.2.100</div></pre></td></tr></table></figure></p>
<p>再来查看一下路由信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# route -n</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.168.0   0.0.0.0         255.255.255.0   U     0      0        0 eth1</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div><div class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure></p>
<p>系统自动添加了192.168.2.0/24这条路由信息。</p>
<h4 id="手动添加路由"><a href="#手动添加路由" class="headerlink" title="手动添加路由"></a>手动添加路由</h4><p>我们可以通过route这条命令手动添加路由信息，但是需要注意的一点就是，<strong>我们所添加的路由，必须是我们主机上的设备（网络接口）或IP可以直接连接的才行。</strong><br>举个例子：我们现在有个路由器IP为192.168.10.254，我们想要连接到这个路由器，可以运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# route add -net 192.168.10.0 netmask 255.255.255.0 gw 192.168.10.254</div><div class="line">SIOCADDRT: No such process</div></pre></td></tr></table></figure></p>
<p>系统提示，不能连接到该网络，应为我们的网络接口与192.168.10.0/24根本就没有关系。那如果192.168.10.254真的是我们的实体网络连接，并且是通过eth0连接在一起的，那其实我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# route add -net 192.168.10.0 netmask 255.255.255.0 dev eth0</div><div class="line">[root@gy-vm02 ~]# route -n</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">192.168.168.0   0.0.0.0         255.255.255.0   U     0      0        0 eth1</div><div class="line">192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div><div class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure></p>
<p>这样，主机就可以通过eth0去连接192.168.10.254了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/29/route/" data-id="ciu2e80g9000p7rhpd0a7h5hj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dns" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/22/dns/" class="article-date">
  <time datetime="2016-05-21T16:00:00.000Z" itemprop="datePublished">2016-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/22/dns/">DNS -- 查询讲解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着IPv4地址的枯竭，IPv6已经开始践行推广起来，可是IPv6是128bits，如果转换成十进制那可得有16个，使用起来会很麻烦，所以以后会越来越普遍使用主机名来进行通讯，这时主机名自动解析为IP就很重要了。DNS服务器，也就越来越重要了。</p>
<h3 id="第一代“DNS”"><a href="#第一代“DNS”" class="headerlink" title="第一代“DNS”"></a>第一代“DNS”</h3><p>最开始的因特网，是没有DNS这个概念的，人们使用TCP/IP协议进行通讯，其中IP为第四版的IPv4，由32个位元组成，转换成十进制的数字就是：100.1.9.88这样子的格式。数据包就是通过这样的IP进行传送数据。<br>可是人脑对于数字的记忆比较费力，尤其是IP越来越多的时候，可是没有IP又不能上internet，那怎么办了？早期的人们想到了一个办法，那就是把IP和主机名一一对应起来，记录到一个特定的档案中，如此一来，我们就可以通过主机名来获得主机IP了，记主机名比记IP要容易的多。/etc/hosts就是那个特定的档案。</p>
<p>这样的方式一开始还比较好用，可是随着internet的推广，需要记录的主机名越来越多，而且主机名和IP这种对应无法自动同步到所有的计算机内，并且要将主机名加入到档案，只能想INTERNIC注册，很不利于同步。</p>
<p><img src="http://vbird.dic.ksu.edu.tw/linux_server/0350dns_files/hosts.gif" alt=""><br>早期透过单一档案进行网络联机的示意图</p>
<h3 id="分布式、阶层式主机名管理架构：-DNS-系统"><a href="#分布式、阶层式主机名管理架构：-DNS-系统" class="headerlink" title="分布式、阶层式主机名管理架构： DNS 系统"></a>分布式、阶层式主机名管理架构： DNS 系统</h3><p>随着internet的大面积使用，单一的档案/etc/hosts的联网问题就遇到了瓶颈，就会发生上述问题。为了解决这个日益严重的问题，柏克利大学研发出一套阶层式管理主机名对应IP的系统，我们称之为 Berkeley Internet Name Domain,简称BIND。这也是目前全世界使用最广泛的领域名系统（Domain Name System, DNS），通过DNS，我们不需要知道主机IP，只要知道主机名称就可以连上该主机了。</p>
<p>DNS利用类似树状目录的架构，将主机名的管理分配在不同层级的DNS服务器当中，经由分层管理，所以每一部DNS服务器记录的信息就不会很多，而且若有IP变动时也很容易修改。因为只要你申请到了主机名解析的授权，那么在你自己的DNS服务器中就能修改，不需要通过上层的ISP来维护。</p>
<p>在分析原理之前，我们先了解几个概念。</p>
<h4 id="FQDN"><a href="#FQDN" class="headerlink" title="FQDN"></a>FQDN</h4><p>FQDN（Fully Qualified Domain Name）完整主机名，是由主机名和领域名（hostname and domain name）组成。那什么是主机名和领域名了？<br>举个例子：<br>长沙有个电话号码4802802，上海也有个电话号码4802802，如果我在长沙本地拨打4802802就会直接拨通到长沙，如果我想要打到上海的4802802，就得在前面加上区号021，才能拨打到上海。这个时候区号021就是对应的领域名，而电话号码就是对应的主机名了。他们组合起来，就是完整主机名，FQDN。<br>薄荷的主页是www.boohee.com，其中www就是主机名，boohee.com就是领域名，百度的主页主机名也是www，但是他的领域名是baidu.com，这样就能区分同名的主机了。<br>前面讲到DNS是以树状目录分阶层的方式来处理主机名，那么这个树状目录中主机名和领域名怎么区分了，我们来看下面图片：<br><img src="http://vbird.dic.ksu.edu.tw/linux_server/0350dns_files/www_ksu.gif" alt=""><br>对于第二层来说，第一层的.tw就是领域名（domain name），而gov、edu、com就是主机名（hostname），而对于第三层来说，edu.tw就变成了domain name，而ntu、ksu就成了hostname。</p>
<h4 id="DNS的阶层架构与TLD"><a href="#DNS的阶层架构与TLD" class="headerlink" title="DNS的阶层架构与TLD"></a>DNS的阶层架构与TLD</h4><p><img src="http://www.goywzl.com/images/server/dns.jpg" alt=""><br>在整个DNS系统的最上方一定是 . （root根），最早以前他底下管理的就只有com、edu、gov、mil、org、net这种特殊领域以及以国家为分类的第二层主机名。这两者称为 Top Level Domains (TLDs)</p>
<ul>
<li>一般最上层领域名 (Generic TLDs, gTLD)：例如 .com, .org, .gov 等等</li>
<li>国码最上层领域名 (Country code TLDs, ccTLD)：例如 .tw, .uk, .jp, .cn 等</li>
</ul>
<p>最早的root仅管理六大领域名，分别如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>com</td>
<td>公司、行号、企业</td>
</tr>
<tr>
<td>org</td>
<td>组织、机构</td>
</tr>
<tr>
<td>edu</td>
<td>教育单位</td>
</tr>
<tr>
<td>gov</td>
<td>政府单位</td>
</tr>
<tr>
<td>net</td>
<td>网络、通讯</td>
</tr>
<tr>
<td>mil</td>
<td>军事单位</td>
</tr>
</tbody>
</table>
<p>但是因特网发展的速度太快了，因此后来除了上述的六大类别之外，还有诸如.asia .info .jobs等领域名的开放。此外，为了让某些国家也能够有自己的最上层领域名，因此就有所谓的ccTLD了。每个国家有了最上层ccTLD，所以如果有domain name的需求，则只要向自己的国家申请即可，不需要到root那里去申请。</p>
<h4 id="授权与分层负责"><a href="#授权与分层负责" class="headerlink" title="授权与分层负责"></a>授权与分层负责</h4><p>既然TLD这么好，那么是否我们可以随便设置TLD了。当然不可以，我们需要向上层的ISP申请领域名的授权才行。例如中国的最上层是领域名是.cn开头，管理这个领域的服务器必须向root(.)注册领域名查询授权才行。<br>当得到授权之后，我们就可以自己管理辖下的主机名或子领域，例如.cn下面也可以划分root管理的那六大类。并且，由于DNS是所谓的阶层式的管理，.cn只记录它下面那一层的主机信息而已。至于sina.com.cn，zol.com.cn是由com.cn这台机器来管理，总结来说<strong>每个上一层的DNS服务器所记录的信息，其实只有其下一层的主机名而已</strong>，至于再下一层，就直接授权给下层的某个主机来管理。<br>这样做的好处就是，每台机器只有下一层的hostname对应的IP而已，所以减少了管理上的困扰！而下层 Client 端如果有问题，只要询问上一层的 DNS server 即可！不需要跨越上层，除错上面也会比较简单！</p>
<h4 id="DNS查询流程"><a href="#DNS查询流程" class="headerlink" title="DNS查询流程"></a>DNS查询流程</h4><p><img src="http://dudns.baidu.com/static/uploads/images/dns-query_20151207015631_954.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">1、用户发出查询请求，首先会去找local dns，也就是我们本地设置的dns服务器，如果在local dns服务器里面找到www.baiduc.com的ip记录就直接返回给用户，然后用户拿着ip去访问百度服务器，如果没找到，就会执行我们上图中的第二步；</div><div class="line">2、如果local dns中没有找到www.baiduc.com对应的ip，local dns服务器首先会向root（根服务器）发出查询请求，但是root服务器只记录了com服务器的ip，local dns拿到com服务器的ip，就会有上图的④查询</div><div class="line">3、当查询到com服务器，com服务器只记录了baidu.com服务器的ip，接下来local dns又去询问baidu.com服务器，也就是第⑥步</div><div class="line">4、当找到baidu.com服务器的时候，这台dns服务器发现自己下面正好记录了www这一台主机，并返回ip给local dns，然后local dns再返回给用户，最终用户得到了www.baidu.com服务器的ip。</div><div class="line"></div><div class="line">在linux或mac系统下面，我们可以使用dig命令，追踪这个过程。</div><div class="line">[ggyy@gy-vm02 one]$ dig +trace www.baidu.com</div><div class="line"></div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.30.rc1.el6 &lt;&lt;&gt;&gt; +trace www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line">.			323984	IN	NS	c.root-servers.net.</div><div class="line">.			323984	IN	NS	j.root-servers.net.</div><div class="line">.			323984	IN	NS	d.root-servers.net.</div><div class="line">.			323984	IN	NS	b.root-servers.net.</div><div class="line">.			323984	IN	NS	h.root-servers.net.</div><div class="line">.			323984	IN	NS	g.root-servers.net.</div><div class="line">.			323984	IN	NS	l.root-servers.net.</div><div class="line">.			323984	IN	NS	a.root-servers.net.</div><div class="line">.			323984	IN	NS	f.root-servers.net.</div><div class="line">.			323984	IN	NS	k.root-servers.net.</div><div class="line">.			323984	IN	NS	m.root-servers.net.</div><div class="line">.			323984	IN	NS	e.root-servers.net.</div><div class="line">.			323984	IN	NS	i.root-servers.net.</div><div class="line">;; Received 228 bytes from 210.22.84.3#53(210.22.84.3) in 77 ms</div><div class="line"></div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">;; Received 491 bytes from 192.112.36.4#53(192.112.36.4) in 371 ms</div><div class="line"></div><div class="line">baidu.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns7.baidu.com.</div><div class="line">;; Received 201 bytes from 192.41.162.30#53(192.41.162.30) in 272 ms</div><div class="line"></div><div class="line">www.baidu.com.		1200	IN	CNAME	www.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">;; Received 228 bytes from 220.181.37.10#53(220.181.37.10) in 34 ms</div></pre></td></tr></table></figure>
<h4 id="DNS-使用的-port-number"><a href="#DNS-使用的-port-number" class="headerlink" title="DNS 使用的 port number"></a>DNS 使用的 port number</h4><p>DNS使用的53这个端口，我们可以在linux下面的/etc/services收索一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep domain /etc/services </div><div class="line">67:domain          53/tcp                          # name-domain server</div><div class="line">68:domain          53/udp</div><div class="line">10025:domaintime      9909/tcp                # domaintime</div><div class="line">10026:domaintime      9909/udp                # domaintime</div></pre></td></tr></table></figure></p>
<p>通常 DNS 查询的时候，是以 udp 这个较快速的数据传输协议来查询的， 但是万一没有办法查询到完整的信息时，就会再次的以 tcp 这个协定来重新查询的！所以启动 DNS 的 daemon (就是 named 啦) 时，会同时启动 tcp 及 udp 的 port 53 喔！所以，记得防火墙也要同时放行 tcp, udp port 53。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/22/dns/" data-id="ciu2e80ey00067rhpe9g9f1os" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/15/command/" class="article-date">
  <time datetime="2016-05-14T16:00:00.000Z" itemprop="datePublished">2016-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/15/command/">command中单双引的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讲今天的主题之前，我们先来了解一下shell中一些基础知识。<br>当我们在shell prompt后面敲打键盘, 直到按下Enter键的时候，你输入的文字就是command line了， 然后shell才会以进程的方式执行你所交给它的命令。 但是，你又可知道：你在command line中输入的每一个文字， 对shell来说，是有类别之分的呢？</p>
<p>简单而言，command line的每一个charactor， 分为如下两种：</p>
<ul>
<li>literal：也就是普通的纯文字，对shell来说没特殊功能；</li>
<li>meta: 对shell来说，具有特定功能的特殊保留元字符。</li>
</ul>
<p>literal就是我们正常输入的字符串， 像 abcd、123456 这些 “文字” 都是 literal，而常用的meta有：</p>
<ul>
<li>IFS（ Interchange Format Syntax ）：有space或者tab或者Enter三者之一组成 (我们常用 space)</li>
<li>CR（回车键）: 由Enter产生；</li>
</ul>
<p>IFS是用来拆解command line中每一个词 (word) 用的， 因为shell command line是按词来处理的。 而CR则是用来结束command line用的，这也是为何我们敲Enter键， 命令就会运行的原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">除了常用的IFS与CR, 常用的 meta 还有：</div><div class="line">= ：  设定变量。</div><div class="line">$ ：  做变量或运算替换(请不要与 shell prompt 搞混了)。</div><div class="line">&gt; ：  重定向 stdout（标准输出standard out）。</div><div class="line">&lt; ：  重定向 stdin（标准输入standard in）。</div><div class="line">|：   管道命令。</div><div class="line">&amp; ：  重定向 file descriptor （文件描述符），或将命令置于后台执行。</div><div class="line">( )： 將其內的命令置于 nested subshell （嵌套的子shell）执行，或用于运算或命令替换。</div><div class="line">&#123; &#125;： 將其內的命令置于 non-named function（未命名函数） 中执行，或用在变量替换的界定范围。</div><div class="line">; ：  在前一个命令结束时，而忽略其返回值，继续执行下一個命令。</div><div class="line">&amp;&amp; ： 在前一個命令结束时，若返回值为 true，继续执行下一個命令。</div><div class="line">|| ： 在前一個命令结束时，若返回值为 false，继续执行下一個命令。</div><div class="line">!：   执行 history 列表中的命令</div></pre></td></tr></table></figure></p>
<p>假如我们需要在command line中将这些保留元字符的功能关闭的话， 就需要 quoting 处理了。<br>在bash中，常用的 quoting 有以下三种方法：</p>
<ul>
<li>hard quote：’’(单引号)，凡在 hard quote 中的所有 meta 均被关闭；</li>
<li>soft quote：””（双引号），在soft quote中的大部分meta都会被关闭，但某些保留（如$）。</li>
<li>escape：\ （反斜线），只有紧接在escape（跳脱字符）之后的单一meta才被关闭。</li>
</ul>
<p>下面我们通过实验来对quote进一步的了解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ A=B C</div><div class="line">-bash: C: command not found</div><div class="line">[ggyy@gy-vm02 ~]$ echo $A</div><div class="line"></div><div class="line">[ggyy@gy-vm02 ~]$ A=&quot;B C&quot;</div><div class="line">[ggyy@gy-vm02 ~]$ echo $A</div><div class="line">B C</div><div class="line">[ggyy@gy-vm02 ~]$</div></pre></td></tr></table></figure></p>
<p>在给第一个A赋值的时候，由于空白符没有被关闭，command line 将被解释为： A=B 然后碰到<ifs>，接着执行C命令，所以会提示一个C命令没找到，并且A赋值也没有成功。<br>在第二次给 A 变量赋值时，由于空白符被置于 soft quote 中， 因此被关闭，不在作为IFS；<br>事实上，空白符无论在 soft quote 还是在 hard quote 中， 均被关闭。Enter 键字符亦然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ A=&apos;B C&apos;</div><div class="line">[ggyy@gy-vm02 ~]$ echo $A</div><div class="line">B C</div></pre></td></tr></table></figure></ifs></p>
<p>我们再来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ a=&apos;1</div><div class="line">&gt; 2</div><div class="line">&gt; 3</div><div class="line">&gt; &apos;</div><div class="line">[ggyy@gy-vm02 ~]$ echo &quot;$a&quot;</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line"></div><div class="line">[ggyy@gy-vm02 ~]$ echo $a</div><div class="line">1 2 3</div></pre></td></tr></table></figure></p>
<p>在上例中，由于 <enter> 被置于 hard quote 当中，因此不再作为 CR 字符來处理。<br>这里的 <enter> 单纯只是一个断行符号(new-line)而已，由于 command line 并沒得到 CR 字符，<br>因此进入第二個 shell prompt (PS2，以 &gt; 符号表示)，command line 并不会结束，<br>直到第四行，我们输入的 <enter> 并不在  hard quote 里面，此时，command line 碰到 CR 字符，于是结束、交给 shell 來处理。<br>但是为什么<figure class="highlight plain"><figcaption><span>"$a" ``` 和 ```echo $a``` 会输出不一样的结果了。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这是因为 ```echo $a ```时的变量沒置于 soft quote 中，因此当变量替换完成后并作命令行重组时，&lt;enter&gt; 会被解释为 IFS ，而不是解释为 New Line 字符。</div><div class="line"></div><div class="line">其实我们可以用 escape 亦可关闭 CR 字符：</div></pre></td></tr></table></figure></enter></enter></enter></p>
<p>[ggyy@gy-vm02 ~]$ a=1\</p>
<blockquote>
<p>2\<br>3<br>[ggyy@gy-vm02 ~]$ echo $a<br>123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">上例中，第一个 &lt;enter&gt; 跟第二个 &lt;enter&gt; 均被 escape 字符关闭了，因此也不作为 CR 來处理，</div><div class="line">但第三个 &lt;enter&gt; 由于没有被转义，因此作为 CR 结束 command line 。</div><div class="line"></div><div class="line">至于 soft quote 跟 hard quote 的不同，主要是对于某些 meta 的关闭与否，以 $ 來作说明：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>[ggyy@gy-vm02 ~]$ a=1<br>[ggyy@gy-vm02 ~]$ echo “$a”<br>1<br>[ggyy@gy-vm02 ~]$ echo ‘$a’<br>$a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">在第一个echo命令行中，$ 被置于 soft quote 中，将不被关闭， 因此继续处理变量替换， 因此，echo将 a 的变量值输出到屏幕，也就是 1 的结果。</div><div class="line"></div><div class="line">在第二个echo命令行中，```$ ```被置于 hard quote 中，则被关闭， 因此，```$``` 只是一个 ```$``` 符号，并不会用来做变量替换处理， 因此结果是``` $``` 符号后面接一个 a 字母：```$a```。</div><div class="line"></div><div class="line">下面这个例子就能完美反映出他们的不同</div></pre></td></tr></table></figure></p>
<p>[ggyy@gy-vm02 ~]$ a=b\ c<br>[ggyy@gy-vm02 ~]$ echo “$a”<br>b c<br>[ggyy@gy-vm02 ~]$ echo $a<br>b c<br>[ggyy@gy-vm02 ~]$ echo ‘“$a”‘<br>“$a”<br>[ggyy@gy-vm02 ~]$ echo “‘$a’”<br>‘b c’<br>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/15/command/" data-id="ciu2e80et00037rhpaq81x373" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-grep" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/08/grep/" class="article-date">
  <time datetime="2016-05-07T16:00:00.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/grep/">linux 基础的正则表达式 -- grep</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>正则表达式（Regular Expression）是通过一些特殊字符的排序，用以查找、替换、删除一行或多行文字字符串，简单的说，正则表达式就是用在字符串的处理上面的一项“表示试”。<br><strong>tips</strong><br>正则表达式并不是一个工具程序，而是一种字符串处理的标准依据，如果你想要以正则表达式的方式处理字符串，就得要使用支持正则表达式的工具程序才行，例如grep、sed、awk等。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep 是一个很常见也很常用的命令，它最重要的功能就是进行字符串数据的对比，然后将符合用户需求的字符串打印出来。需要说明的是grep在数据中查找一个字符串，是以整行为单位来进行数据的选取的。也就是说，假如一个文件内有10行，其中有两行具有你所查找的字符串，则将那两行显示在屏幕上，其他的就丢弃了。</p>
<p>-n和–color=auto 是grep常用的两个参数，如果每次使用的时候都要去敲这两个参数又太麻烦。可以在~/.bash_profile中假如这行：alias grep=”grep –color -n”。</p>
<h4 id="查找特定的字符串"><a href="#查找特定的字符串" class="headerlink" title="查找特定的字符串"></a>查找特定的字符串</h4><p>1、从文件中查找good字符串，用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep good regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">9:Oh! The soup taste good.</div></pre></td></tr></table></figure></p>
<p>加上-v参数则是取相反的结果，-i是不区分大小写</p>
<p>2、使用[]中括号来查找集合字符<br>如果要查找test和tast这两个单词时，可以使用如下表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;t[ea]st&apos; regular.txt </div><div class="line">8:I can&apos;t finish the test.</div><div class="line">9:Oh! The soup taste good.</div></pre></td></tr></table></figure></p>
<p>[]中括号表示不论里面几个字符，都自会选则一个字符。</p>
<p>如果想要找到oo字符，但是前面没有g字符，可以使用如下表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;[^g]oo&apos; regular.txt </div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果oo前面不想有小写字符，可以使用如下表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;[^a-z]oo&apos; regular.txt </div><div class="line">3:Football game is not use feet only.</div></pre></td></tr></table></figure></p>
<p>当在一组集合字符中，如果该字符组是连续的，例如大/小写英文，数字等，就可以使用[a-z]，[A-Z]，[0-9]这样来表达，那么如果是要求字符串是数字和英文，就就它们写在一起,[a-zA-Z0-9]。<br>例如，我们要找出如有带数字的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep [0-9] regular.txt </div><div class="line">5:However, this dress is about $ 3183 dollars.</div><div class="line">15:You are the best is mean you are the no. 1.</div></pre></td></tr></table></figure></p>
<p>3、行首与行尾字符^$<br>如果我们要查找以the字符串开头的行，使用如下表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;^the&apos; regular.txt </div><div class="line">12:the symbol &apos;*&apos; is represented as start.</div></pre></td></tr></table></figure></p>
<p>如果我们想要找开头是小写字符的那一行，可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;^[a-z]&apos; regular.txt </div><div class="line">2:apple is my favorite food.</div><div class="line">4:this dress doesn&apos;t fit me.</div><div class="line">10:motorcycle is cheap than car.</div><div class="line">12:the symbol &apos;*&apos; is represented as start.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let&apos;s go.</div></pre></td></tr></table></figure></p>
<p>如我们不想开头是英文字符，可以使用如下表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;^[^a-zA-Z]&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">21:# I am VBird</div></pre></td></tr></table></figure></p>
<p><strong>tips</strong><br>^符号在字符集合[]之内表示反向选择，在[]之外，表示定位行首的意义，要区分清楚。</p>
<p>那如果我们想要找出以小数点 . 结尾的那一行，则这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;\.$&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">4:this dress doesn&apos;t fit me.</div><div class="line">10:motorcycle is cheap than car.</div><div class="line">11:This window is clear.</div><div class="line">12:the symbol &apos;*&apos; is represented as start.</div><div class="line">15:You are the best is mean you are the no. 1.</div><div class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</div><div class="line">17:I like dog.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">20:go! go! Let&apos;s go.</div></pre></td></tr></table></figure></p>
<p>我们经常查看一些配置文件，里面有大量的注释信息和一些空行，那么我们可以使用如下方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep -v &apos;^$&apos; regular.txt | grep -v &apos;^#&apos; </div><div class="line">1:1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">2:2:apple is my favorite food.</div><div class="line">3:3:Football game is not use feet only.</div><div class="line">4:4:this dress doesn&apos;t fit me.</div><div class="line">5:5:However, this dress is about $ 3183 dollars.</div><div class="line">6:6:GNU is free air not free beer.</div><div class="line">7:7:Her hair is very beauty.</div></pre></td></tr></table></figure></p>
<p>4、任意字符 . 和重复字符*</p>
<ul>
<li>.（小数点）：代表一定有一个任意字符的意思</li>
<li>*（星号）：代表重复前一个字符0到无穷多次的意思。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;g..d&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的表达式是强调g与d之间一定要有两个字符，所以如果只有一个字符或者没有字符或者超过两个字符的都不会匹配。</p>
<p>再看如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;ooo*&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>我们知道 <em> 表示重复前面一个字符0到无穷次个，因此，o</em> 代表具有空字符或一个以上的字符，特别注意，<em> 为0时表示空字符串，“[ggyy@gy-vm02 ~]$ grep  ‘o</em>‘ regular.txt”会把所有的数据都输出出来。<br>如果是“oo<em> ”，则第一个o肯定必须存在，第二个o则是可有可无的多个o，同理，当我们需要至少两个o以上的字符串时，就需要ooo</em> </p>
<p>那如果我们想要字符串开头与结尾都是g，但是两个g之间仅能存在至少一个o，即gog、goog、gooog等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep  &apos;goo*g&apos; regular.txt </div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>那如果我们想要找到g开头和g结尾的字符串，中间可有可无，如何表达了?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;g.*g&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">14:The gd software is a library for drafting programs.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let&apos;s go.</div></pre></td></tr></table></figure></p>
<p>5、限定连续的字符范围<br>我们在上面的例子中利用 . * 来设置0到无限个重复字符，那如何限定一个范围了。<br>比如说，我想找出2-4个o的连续字符串，这个时候，就得使用到限定范围的字符｛｝了。但是因为｛｝符号在shell里面是有特殊意义的，因此我们需要用上转义字符\来让他失去特殊意义才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;o\&#123;2,4\&#125;&apos; regular.txt </div><div class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果我们想要找到g后面有2个o以上，并且是g结尾的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ grep &apos;go\&#123;2,\&#125;g&apos; regular.txt </div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>这样就好了。</p>
<p>最后强调一下，正则表达式的特殊字符与一般在命令行的“通配符”并不相同，例如，在通配符中的* 代表的是零到无限多个字符的意思，但是在正则表达式中，则是重复0到无穷个前一个匹配字符的意思。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/08/grep/" data-id="ciu2e80f7000c7rhpqoymis4h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/25/php-cgi/">使用Spawn-FCGI管理php-cgi</a>
          </li>
        
          <li>
            <a href="/2016/09/17/ngxtop/">ngxtop---nginx日志实时监控工具</a>
          </li>
        
          <li>
            <a href="/2016/09/04/conntrack/">系统内核参数--nf_conntrack</a>
          </li>
        
          <li>
            <a href="/2016/08/28/tmpwatch/">tmpwatch</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>