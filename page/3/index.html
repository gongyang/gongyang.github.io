<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mongodb_index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/01/mongodb_index/" class="article-date">
  <time datetime="2016-04-30T16:00:00.000Z" itemprop="datePublished">2016-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/01/mongodb_index/">Mongodb 索引详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用索引，mongodb可以执行有效率的查询。如果没有索引，mongodb必须对整个集合进行扫描，扫描集合中的每一个文档来找到匹配的查询。如果建立一个合适的索引来进行查询，mongodb可以通过查找索引，可以快速对文档进行定位。</p>
<p>下面我们来看一个例子：<br>在命令行输入mongo，mongodb会默认连接test数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm03 ~]$ mongo</div><div class="line">MongoDB shell version: 3.0.0、</div><div class="line">connecting to: test</div><div class="line">&gt;show tables</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>然后在mongodb shell执行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; for(var i=0;i&lt;100000;i++) &#123;</div><div class="line">... db.users.insert(&#123;username:&apos;user&apos;+i&#125;)</div><div class="line">... &#125;</div><div class="line">&gt; show collections</div><div class="line">users</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>现在我们从users集合中查询一条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.find(&#123;username:&quot;user11223&quot;&#125;)</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;572027b16dae65d12fb33c33&quot;), &quot;username&quot; : &quot;user11223&quot; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>成功的找到了数据，但是并看不出什么其他信息。我们在查询语句后面加上<a href="https://docs.mongodb.org/manual/reference/method/cursor.explain/" target="_blank" rel="external">explain</a>方法再来看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.find(&#123;username:&quot;user11223&quot;&#125;).explain(&quot;executionStats&quot;)</div><div class="line">&#123;</div><div class="line">	&quot;queryPlanner&quot; : &#123;</div><div class="line">		&quot;plannerVersion&quot; : 1,</div><div class="line">		&quot;namespace&quot; : &quot;test.users&quot;,</div><div class="line">		&quot;indexFilterSet&quot; : false,</div><div class="line">		&quot;parsedQuery&quot; : &#123;</div><div class="line">			&quot;username&quot; : &#123;</div><div class="line">				&quot;$eq&quot; : &quot;user11223&quot;</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		&quot;winningPlan&quot; : &#123;</div><div class="line">			&quot;stage&quot; : &quot;COLLSCAN&quot;,</div><div class="line">			&quot;filter&quot; : &#123;</div><div class="line">				&quot;username&quot; : &#123;</div><div class="line">					&quot;$eq&quot; : &quot;user11223&quot;</div><div class="line">				&#125;</div><div class="line">			&#125;,</div><div class="line">			&quot;direction&quot; : &quot;forward&quot;</div><div class="line">		&#125;,</div><div class="line">		&quot;rejectedPlans&quot; : [ ]</div><div class="line">	&#125;,</div><div class="line">	&quot;executionStats&quot; : &#123;</div><div class="line">		&quot;executionSuccess&quot; : true,</div><div class="line">		&quot;nReturned&quot; : 1,</div><div class="line">		&quot;executionTimeMillis&quot; : 40,</div><div class="line">		&quot;totalKeysExamined&quot; : 0,</div><div class="line">		&quot;totalDocsExamined&quot; : 100000,</div><div class="line">		&quot;executionStages&quot; : &#123;</div><div class="line">			&quot;stage&quot; : &quot;COLLSCAN&quot;,</div><div class="line">			&quot;filter&quot; : &#123;</div><div class="line">				&quot;username&quot; : &#123;</div><div class="line">					&quot;$eq&quot; : &quot;user11223&quot;</div><div class="line">				&#125;</div><div class="line">			&#125;,</div><div class="line">			&quot;nReturned&quot; : 1,</div><div class="line">			&quot;executionTimeMillisEstimate&quot; : 30,</div><div class="line">			&quot;works&quot; : 100002,</div><div class="line">			&quot;advanced&quot; : 1,</div><div class="line">			&quot;needTime&quot; : 100000,</div><div class="line">			&quot;needFetch&quot; : 0,</div><div class="line">			&quot;saveState&quot; : 781,</div><div class="line">			&quot;restoreState&quot; : 781,</div><div class="line">			&quot;isEOF&quot; : 1,</div><div class="line">			&quot;invalidates&quot; : 0,</div><div class="line">			&quot;direction&quot; : &quot;forward&quot;,</div><div class="line">			&quot;docsExamined&quot; : 100000</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	&quot;serverInfo&quot; : &#123;</div><div class="line">		&quot;host&quot; : &quot;gy-vm03&quot;,</div><div class="line">		&quot;port&quot; : 27017,</div><div class="line">		&quot;version&quot; : &quot;3.0.0&quot;,</div><div class="line">		&quot;gitVersion&quot; : &quot;a841fd6394365954886924a35076691b4d149168&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>哇，好多内容啊，看不懂没关系，我们只关注”executionTimeMillis”,”totalDocsExamined”这两个参数，可以发现，集合中的每个文档都被扫描了，并且总时间为40毫秒。如果要是这个集合有几千万的数据，那这个服务器基本上就挂了。<br>那么，如果我们给username加上一个索引，效果又如何了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.createIndex(&#123;username:1&#125;)</div><div class="line">&#123;</div><div class="line">	&quot;createdCollectionAutomatically&quot; : false,</div><div class="line">	&quot;numIndexesBefore&quot; : 1,</div><div class="line">	&quot;numIndexesAfter&quot; : 2,</div><div class="line">	&quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line">&gt; db.users.getIndexes()</div><div class="line">[</div><div class="line">	&#123;</div><div class="line">		&quot;v&quot; : 1,</div><div class="line">		&quot;key&quot; : &#123;</div><div class="line">			&quot;_id&quot; : 1</div><div class="line">		&#125;,</div><div class="line">		&quot;name&quot; : &quot;_id_&quot;,</div><div class="line">		&quot;ns&quot; : &quot;test.users&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;v&quot; : 1,</div><div class="line">		&quot;key&quot; : &#123;</div><div class="line">			&quot;username&quot; : 1</div><div class="line">		&#125;,</div><div class="line">		&quot;name&quot; : &quot;username_1&quot;,</div><div class="line">		&quot;ns&quot; : &quot;test.users&quot;</div><div class="line">	&#125;</div><div class="line">]</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>索引被成功的创建，接下来我们再次执行上一条查询语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.find(&#123;username:&quot;user19223&quot;&#125;).explain(&quot;executionStats&quot;)</div><div class="line">&#123;</div><div class="line">	&quot;queryPlanner&quot; : &#123;</div><div class="line">		&quot;plannerVersion&quot; : 1,</div><div class="line">		&quot;namespace&quot; : &quot;test.users&quot;,</div><div class="line">		&quot;indexFilterSet&quot; : false,</div><div class="line">		&quot;parsedQuery&quot; : &#123;</div><div class="line">			&quot;username&quot; : &#123;</div><div class="line">				&quot;$eq&quot; : &quot;user19223&quot;</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		&quot;winningPlan&quot; : &#123;</div><div class="line">			&quot;stage&quot; : &quot;FETCH&quot;,</div><div class="line">			&quot;inputStage&quot; : &#123;</div><div class="line">				&quot;stage&quot; : &quot;IXSCAN&quot;,</div><div class="line">				&quot;keyPattern&quot; : &#123;</div><div class="line">					&quot;username&quot; : 1</div><div class="line">				&#125;,</div><div class="line">				&quot;indexName&quot; : &quot;username_1&quot;,</div><div class="line">				&quot;isMultiKey&quot; : false,</div><div class="line">				&quot;direction&quot; : &quot;forward&quot;,</div><div class="line">				&quot;indexBounds&quot; : &#123;</div><div class="line">					&quot;username&quot; : [</div><div class="line">						&quot;[\&quot;user19223\&quot;, \&quot;user19223\&quot;]&quot;</div><div class="line">					]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		&quot;rejectedPlans&quot; : [ ]</div><div class="line">	&#125;,</div><div class="line">	&quot;executionStats&quot; : &#123;</div><div class="line">		&quot;executionSuccess&quot; : true,</div><div class="line">		&quot;nReturned&quot; : 1,</div><div class="line">		&quot;executionTimeMillis&quot; : 0,</div><div class="line">		&quot;totalKeysExamined&quot; : 1,</div><div class="line">		&quot;totalDocsExamined&quot; : 1,</div><div class="line">		&quot;executionStages&quot; : &#123;</div><div class="line">			&quot;stage&quot; : &quot;FETCH&quot;,</div><div class="line">			&quot;nReturned&quot; : 1,</div><div class="line">			&quot;executionTimeMillisEstimate&quot; : 0,</div><div class="line">			&quot;works&quot; : 2,</div><div class="line">			&quot;advanced&quot; : 1,</div><div class="line">			&quot;needTime&quot; : 0,</div><div class="line">			&quot;needFetch&quot; : 0,</div><div class="line">			&quot;saveState&quot; : 0,</div><div class="line">			&quot;restoreState&quot; : 0,</div><div class="line">			&quot;isEOF&quot; : 1,</div><div class="line">			&quot;invalidates&quot; : 0,</div><div class="line">			&quot;docsExamined&quot; : 1,</div><div class="line">			&quot;alreadyHasObj&quot; : 0,</div><div class="line">			&quot;inputStage&quot; : &#123;</div><div class="line">				&quot;stage&quot; : &quot;IXSCAN&quot;,</div><div class="line">				&quot;nReturned&quot; : 1,</div><div class="line">				&quot;executionTimeMillisEstimate&quot; : 0,</div><div class="line">				&quot;works&quot; : 2,</div><div class="line">				&quot;advanced&quot; : 1,</div><div class="line">				&quot;needTime&quot; : 0,</div><div class="line">				&quot;needFetch&quot; : 0,</div><div class="line">				&quot;saveState&quot; : 0,</div><div class="line">				&quot;restoreState&quot; : 0,</div><div class="line">				&quot;isEOF&quot; : 1,</div><div class="line">				&quot;invalidates&quot; : 0,</div><div class="line">				&quot;keyPattern&quot; : &#123;</div><div class="line">					&quot;username&quot; : 1</div><div class="line">				&#125;,</div><div class="line">				&quot;indexName&quot; : &quot;username_1&quot;,</div><div class="line">				&quot;isMultiKey&quot; : false,</div><div class="line">				&quot;direction&quot; : &quot;forward&quot;,</div><div class="line">				&quot;indexBounds&quot; : &#123;</div><div class="line">					&quot;username&quot; : [</div><div class="line">						&quot;[\&quot;user19223\&quot;, \&quot;user19223\&quot;]&quot;</div><div class="line">					]</div><div class="line">				&#125;,</div><div class="line">				&quot;keysExamined&quot; : 1,</div><div class="line">				&quot;dupsTested&quot; : 0,</div><div class="line">				&quot;dupsDropped&quot; : 0,</div><div class="line">				&quot;seenInvalidated&quot; : 0,</div><div class="line">				&quot;matchTested&quot; : 0</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	&quot;serverInfo&quot; : &#123;</div><div class="line">		&quot;host&quot; : &quot;gy-vm03&quot;,</div><div class="line">		&quot;port&quot; : 27017,</div><div class="line">		&quot;version&quot; : &quot;3.0.0&quot;,</div><div class="line">		&quot;gitVersion&quot; : &quot;a841fd6394365954886924a35076691b4d149168&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以看到通过索引，只扫描了一条数据，并且这次查询几乎是没有花时间。<br>当然使用索引是也是有代价的：对于添加的每一条索引，每次写操作（插入、更新、删除）都将耗费更多的时间。这是因为，当数据发生变化时，不仅要更新文档，还要更新级集合上的所有索引。因此，mongodb限制每个集合最多有64个索引，索引名的长度不能超过125个字符。通常，在一个特定集合中，索引数最好不要超过2个，选择热点键或有可能是性能瓶颈的键做索引。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="单键索引"><a href="#单键索引" class="headerlink" title="单键索引"></a>单键索引</h3><p>mongodb支持对集合中文档的任一键建立索引（mongodb中的集合就是table，键就是column）。每个集合默认都有一个_id键的索引。用户可以另外添加索引来支持重要的查询和操作。</p>
<p><strong>创建一个索引</strong><br>在users集合上面创建一个单键索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; &#123; &quot;_id&quot; : objectid(...),</div><div class="line">&gt;   &quot;name&quot;: &quot;bobo&quot;,</div><div class="line">&gt;   &quot;age&quot; : 20</div><div class="line">&gt; &#125;</div></pre></td></tr></table></figure></p>
<p>使用<strong>createIndex</strong>命令在name键上面建立索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.cerateIndex(&#123;&quot;name&quot; : 1&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>_id键上的索引</strong><br>mongodb在我们创建集合的时候，自动会在_id键上面创建_id索引,并且是唯一索引。我们不能从_id键上面移除这个索引。</p>
<p><strong>内嵌文档键的索引（Indexes on Embedded Fields）</strong><br>people collection<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&quot;_id&quot;: ObjectId(...),</div><div class="line">&gt;  &quot;name&quot;: &quot;John Doe&quot;,</div><div class="line">&gt;  &quot;address&quot;: &#123;</div><div class="line">&gt;        &quot;street&quot;: &quot;Main&quot;,</div><div class="line">&gt;        &quot;zipcode&quot;: &quot;53511&quot;,</div><div class="line">&gt;        &quot;state&quot;: &quot;WI&quot;</div><div class="line">&gt;        &#125;</div><div class="line">&gt; &#125;</div></pre></td></tr></table></figure></p>
<p>对address.zipcode创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.people.createIndex( &#123; &quot;address.zipcode&quot;: 1 &#125; )</div></pre></td></tr></table></figure></p>
<p>对如下集合metro创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;</div><div class="line">&gt;  _id: ObjectId(...),</div><div class="line">&gt;  metro: &#123;</div><div class="line">&gt;           city: &quot;New York&quot;,</div><div class="line">&gt;           state: &quot;NY&quot;</div><div class="line">&gt;         &#125;,</div><div class="line">&gt;  name: &quot;Giant Factory&quot;</div><div class="line">&gt; &#125;</div></pre></td></tr></table></figure></p>
<p>metro键是一个内嵌文档，包含city，state两个内嵌键，下面的命令可以对metro键创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.factories.createIndex( &#123; metro: 1 &#125; )</div></pre></td></tr></table></figure></p>
<p>如下查询可以利用到基于metro键的索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.factories.find( &#123; metro: &#123; city: &quot;New York&quot;, state: &quot;NY&quot; &#125; &#125; )</div></pre></td></tr></table></figure></p>
<p>但是如下查询却不能使用metro索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.factories.find( &#123; metro: &#123; state: &quot;NY&quot;, city: &quot;New York&quot; &#125; &#125; )</div></pre></td></tr></table></figure></p>
<p>这是因为，我们的查询匹配键，必须和内嵌文档键顺序完全匹配。</p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>什么是复合索引，就是索引中可以包含集合中文档的多个键。复合索引可以支持要求匹配多个键的查询<br>例如集合club_posts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; </div><div class="line"> &quot;_id&quot; : 51, </div><div class="line"> &quot;post_id&quot; : 7353, </div><div class="line"> &quot;sticky&quot; : false, </div><div class="line"> &quot;club_id&quot; : 1 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用需要查询post_id键，有时还需要同时查询post_id和club_id键，那么我们可以创建一个复合索引键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;db.club_posts.createIndex(&#123;post_id:1,club_id:1&#125;)</div><div class="line">&#123;</div><div class="line">	&quot;createdCollectionAutomatically&quot; : false,</div><div class="line">	&quot;numIndexesBefore&quot; : 1,</div><div class="line">	&quot;numIndexesAfter&quot; : 2,</div><div class="line">	&quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>tips:</strong><br>我们不能对hashed键创建复合建索，这样会报错。</p>
<h3 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h3><p>假如有文档posts，其结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&#123;</div><div class="line">	&quot;_id&quot; : 16,</div><div class="line">	&quot;body&quot; : &quot;dGagrshrshre&quot;,</div><div class="line">	&quot;created_at&quot; : ISODate(&quot;2013-09-30T06:45:33.862Z&quot;),</div><div class="line">	&quot;deleted_at&quot; : null,</div><div class="line">	&quot;envious_count&quot; : 1,</div><div class="line">	&quot;feedbacks&quot; : [</div><div class="line">		&#123;</div><div class="line">			&quot;type&quot; : &quot;envious&quot;,</div><div class="line">			&quot;user_id&quot; : 24,</div><div class="line">			&quot;updated_at&quot; : ISODate(&quot;2013-09-30T07:01:46.897Z&quot;),</div><div class="line">			&quot;created_at&quot; : ISODate(&quot;2013-09-30T07:01:46.897Z&quot;),</div><div class="line">			&quot;_id&quot; : 37</div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	&quot;hateful_count&quot; : 0,</div><div class="line">	&quot;jealous_count&quot; : 0,</div><div class="line">	&quot;type&quot; : &quot;&quot;,</div><div class="line">	&quot;updated_at&quot; : ISODate(&quot;2014-05-04T10:26:40.235Z&quot;)</div><div class="line">	｝</div></pre></td></tr></table></figure></p>
<p>如果我们对feedbacks这个键创建了索引，由于这是一个数组，为了索引一个储存数组的键，MongoDB对数组中的每个元素都添加索引项，我们不需要显示地指定索引为多键类型<br>创建多键索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.posts.createIndex(&#123;feedbacks:1&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>使用限制</strong><br>我们可以创建一个包含有多键索引的复合索引，但是在复合索引中最多只能有一个多键索引。例如，有一个索引 { a: 1, b: 1 }, 以下的文档是允许的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; _id: 1, a: [1, 2], b: 1, category: &quot;A array&quot; &#125;</div><div class="line">&#123; _id: 2, a: 1, b: [1, 2], category: &quot;B array&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>但是，如下的文档就是不被允许的，而且MongoDB将不会把这样的一个文档存储到集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: &quot;AB - both arrays&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>mongodb还支持地理空间索引和查询、文本索引、哈希索引等。</p>
<h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2><h3 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h3><p>TTL索引是一种特殊索引，通过这种索引MongoDB会过一段时间后自动移除集合中的文档。这对于某些类型的信息来说是一个很理想的特性，例如机器生成的事件数据，日志，会话信息等，这些数据都只需要在数据库中保存有限时间。<br>使用TTL属性，只需要在创建索引的时候加上expireAfterSeconds方法</p>
<p>例如，如下操作在 log_events 集合的createdAt字段创建了一个索引并指定 expireAfterSeconds的值为60以使过期时间为createdAt指定的时间之后的一分钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.log_events.createIndex( &#123; &quot;createdAt&quot;: 1 &#125;, &#123; expireAfterSeconds: 60 &#125; )</div></pre></td></tr></table></figure></p>
<p>当向 log_events 集合添加文档时，设置 createdAt 字段为当前时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; db.log_events.insert( &#123;</div><div class="line">...    &quot;createdAt&quot;: new Date(),</div><div class="line">...    &quot;logEvent&quot;: 2,</div><div class="line">...    &quot;logMessage&quot;: &quot;Success!&quot;</div><div class="line">... &#125; )</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div></pre></td></tr></table></figure></p>
<p>这样log_events集合里面的文档的createdAt字段的值晚于 expireAfterSeconds中指定的秒数时，MongoDB会自动从log_events 集合删除该文档。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引可以让MongoDB拒绝保存那些被索引键的值已经重复的文档。<br>创建一个唯一索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.collection.createIndex( &#123; a: 1 &#125;, &#123; unique: true &#125; )</div></pre></td></tr></table></figure></p>
<p>也可以对 复合索引 施加唯一性限制，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.collection.createIndex( &#123; a: 1, b: 1 &#125;, &#123; unique: true &#125; )</div></pre></td></tr></table></figure></p>
<p>这个索引会强制要求 复合 键值的唯一性，而 不是 每个键的唯一性。</p>
<h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><p>稀疏索引中值存储那些有被索引键的文档的索引项，即使被索引键的值是null也会被索引(译者注：请注意，这里对null的处理和那些特殊索引的默认稀疏特性有细微差别，比如文本索引，2d索引等)。索引会跳过所有不包含被索引键的文档。这个索引之所以称为 “稀疏” 是因为它并不包括集合中的所有文档。与之相反，非稀疏的索引会索引每一篇文档，如果一篇文档不含被索引键则为它存储一个null值。<br>创建一个稀疏索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.collection.createIndex( &#123; a: 1 &#125;, &#123; sparse: true &#125; )</div></pre></td></tr></table></figure></p>
<p>在A集合上创建稀疏索引<br>假设集合 scores 有如下文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; &quot;_id&quot; : ObjectId(&quot;523b6e32fb408eea0eec2647&quot;), &quot;userid&quot; : &quot;newbie&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e61fb408eea0eec2648&quot;), &quot;userid&quot; : &quot;abby&quot;, &quot;score&quot; : 82 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e6ffb408eea0eec2649&quot;), &quot;userid&quot; : &quot;nina&quot;, &quot;score&quot; : 90 &#125;</div></pre></td></tr></table></figure></p>
<p>集合在 score 键上有一个稀疏索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.scores.createIndex( &#123; score: 1 &#125; , &#123; sparse: true &#125; )</div></pre></td></tr></table></figure></p>
<p>那么，在 scores 集合上执行如下查询，将会利用稀疏索引来返回包含了 score 键且值小于 ($lt) 90 的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.scores.find( &#123; score: &#123; $lt: 90 &#125; &#125; )</div></pre></td></tr></table></figure></p>
<p>由于userid为 “newbie” 的文档不包含 score 键，因此无法满足查询条件，那么查询可以利用稀疏索引来返回如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; &quot;_id&quot; : ObjectId(&quot;523b6e61fb408eea0eec2648&quot;), &quot;userid&quot; : &quot;abby&quot;, &quot;score&quot; : 82 &#125;</div></pre></td></tr></table></figure></p>
<p>在A集合上的稀疏索引不会返回完整结果</p>
<p>假设集合 scores 有如下文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&#123; &quot;_id&quot; : ObjectId(&quot;523b6e32fb408eea0eec2647&quot;), &quot;userid&quot; : &quot;newbie&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e61fb408eea0eec2648&quot;), &quot;userid&quot; : &quot;abby&quot;, &quot;score&quot; : 82 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e6ffb408eea0eec2649&quot;), &quot;userid&quot; : &quot;nina&quot;, &quot;score&quot; : 90 &#125;</div></pre></td></tr></table></figure></p>
<p>集合在 score 键上有一个稀疏索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.scores.createIndex( &#123; score: 1 &#125; , &#123; sparse: true &#125; )</div></pre></td></tr></table></figure></p>
<p>由于userid为 “newbie” 的文档不包含 score 键， 因此稀疏索引中不包含该文档的索引项。</p>
<p>假设有如下查询，返回 scores 集合中 所有 文档并按照 score 键排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; db.scores.find().sort( &#123; score: -1 &#125; )</div></pre></td></tr></table></figure></p>
<p>即使是按照被索引键排序，MongoDB仍然 不会 选择稀疏索引来匹配这个查询，这是为了可以得到完整的结果集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&quot;_id&quot; : ObjectId(&quot;523b6e6ffb408eea0eec2649&quot;), &quot;userid&quot; : &quot;nina&quot;, &quot;score&quot; : 90 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e61fb408eea0eec2648&quot;), &quot;userid&quot; : &quot;abby&quot;, &quot;score&quot; : 82 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e32fb408eea0eec2647&quot;), &quot;userid&quot; : &quot;newbie&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>如果希望使用稀疏索引，请在 hint() 显示指定该索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.scores.find().sort( &#123; score: -1 &#125; ).hint( &#123; score: 1 &#125; )</div></pre></td></tr></table></figure></p>
<p>稀疏索引的使用导致了只有那些包含 score 键的文档被返回了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &#123; &quot;_id&quot; : ObjectId(&quot;523b6e6ffb408eea0eec2649&quot;), &quot;userid&quot; : &quot;nina&quot;, &quot;score&quot; : 90 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;523b6e61fb408eea0eec2648&quot;), &quot;userid&quot; : &quot;abby&quot;, &quot;score&quot; : 82 &#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/01/mongodb_index/" data-id="ciu2e80fe000g7rhp08ns6x2o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ansible" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/24/ansible/" class="article-date">
  <time datetime="2016-04-23T16:00:00.000Z" itemprop="datePublished">2016-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/24/ansible/">自动化运维工具ansible--入门使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是ansible"><a href="#什么是ansible" class="headerlink" title="什么是ansible"></a>什么是ansible</h3><p>Ansible is Simple IT Automation，是一个自动化运维的工具，基于Python开发，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Ansible默认通过 SSH 协议管理机器，安装Ansible之后,不需要启动或运行一个后台进程,或是添加一个数据库。只要在一台电脑(可以是一台笔记本)上安装好,就可以通过这台电脑管理一组远程的机器.在远程被管理的机器上,不需要安装运行任何软件,因此升级Ansible版本不会有太多问题。</p>
<p>目前,只要机器上安装了 Python 2.6 (windows系统不可以做控制主机),都可以运行Ansible。主机的系统可以是 Red Hat, Debian, CentOS, OS X, BSD的各种版本,等等</p>
<h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git://github.com/ansible/ansible.git --recursive</div><div class="line">$ cd ./ansible</div><div class="line">$ source ./hacking/env-setup</div></pre></td></tr></table></figure>
<p>如果没有安装pip, 请先安装对应于你的Python版本的pip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo easy_install pip</div></pre></td></tr></table></figure></p>
<p>以下的Python模块也需要安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install paramiko PyYAML Jinja2 httplib2</div></pre></td></tr></table></figure></p>
<p>注意,当更新ansible版本时,不只要更新git的源码树,也要更新git中指向Ansible自身模块的 “submodules” (不是同一种模块)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git pull --rebase</div><div class="line">$ git submodule update --init --recursive</div></pre></td></tr></table></figure></p>
<h4 id="Yum安装"><a href="#Yum安装" class="headerlink" title="Yum安装"></a>Yum安装</h4><p>通过Yum安装RPM适用于 EPEL 6, 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install ansible</div></pre></td></tr></table></figure></p>
<p>你也可以自己创建RPM软件包。在Ansible项目的checkout的根目录下,或是在一个tarball中,使用 make rpm 命令创建RPM软件包。然后可分发这个软件包或是使用它来安装Ansible。在创建之前,先确定你已安装了 rpm-build, make, and python2-devel 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone git://github.com/ansible/ansible.git</div><div class="line">$ cd ./ansible</div><div class="line">$ make rpm</div><div class="line">$ sudo rpm -Uvh ~/rpmbuild/ansible-*.noarch.rpm</div></pre></td></tr></table></figure></p>
<p>其他系统的安装方式，请参考<a href="http://docs.ansible.com/ansible/intro_installation.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="inventory-file"><a href="#inventory-file" class="headerlink" title="inventory file"></a>inventory file</h3><p>在我们开始前要先理解Ansible是如何通过SSH与远程服务器连接是很重要的。<br>Ansible 1.3及之后的版本默认会在本地的 OpenSSH可用时会尝试用其进行远程通讯。这会启用ControlPersist(一个性能特性),Kerberos,和在~/.ssh/config中的配置选项如 Jump Host setup。然而,当你使用Linux企业版6作为主控机(红帽企业版及其衍生版如CentOS),其OpenSSH版本可能过于老旧无法支持ControlPersist。在这些操作系统中,Ansible将会退回并采用 paramiko (由Python实现的高质量OpenSSH库)。 如果你希望能够使用像是Kerberized SSH之类的特性,烦请考虑使用Fedora, OS X, 或 Ubuntu 作为你的主控机直到相关平台上有更新版本的OpenSSH可供使用,或者启用Ansible的“accelerated mode”。</p>
<p>现在你已经安装了Ansible,是时候从一些基本知识开始了. 编辑(或创建)/etc/ansible/hosts 并在其中加入一个或多个远程系统。你的public SSH key必须在这些系统的“authorized_keys”中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ cat /etc/ansible/hosts</div><div class="line">[vm03]</div><div class="line">192.168.1.124:9999</div><div class="line"></div><div class="line">[vm04]</div><div class="line">192.168.1.140</div><div class="line"></div><div class="line">[vm07]</div><div class="line">192.168.1.108 ansible_ssh_user=root</div></pre></td></tr></table></figure></p>
<p>这个文件叫做节点设置文件(inventory file)，默认的文件路径为 /etc/ansible/hosts，其中[]叫做组名，用于对系统进行分类,便于对不同系统进行个别的管理。一个系统可以属于不同的组,比如一台服务器可以同时属于 webserver组 和 dbserver组。<br>如果有主机的SSH端口不是标准的22端口,可在主机名之后加上端口号,用冒号分隔，例如上面的主机vm03。<br>如果有一组相似的 hostname , 可简写如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[webservers]</div><div class="line">www[01:50].example.com</div></pre></td></tr></table></figure></p>
<p>对于每一个 host,你还可以选择连接用户名,默认是管理主机的当前用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vm07]</div><div class="line">192.168.1.108 ansible_ssh_user=root</div></pre></td></tr></table></figure></p>
<p>更多Inventory 参数的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ansible_ssh_host</div><div class="line">      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</div><div class="line"></div><div class="line">ansible_ssh_port</div><div class="line">      ssh端口号.如果不是默认的端口号,通过此变量设置.</div><div class="line"></div><div class="line">ansible_ssh_user</div><div class="line">      默认的 ssh 用户名</div><div class="line"></div><div class="line">ansible_ssh_pass</div><div class="line">      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</div><div class="line"></div><div class="line">ansible_sudo_pass</div><div class="line">      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</div><div class="line"></div><div class="line">ansible_sudo_exe (new in version 1.8)</div><div class="line">      sudo 命令路径(适用于1.8及以上版本)</div><div class="line"></div><div class="line">ansible_connection</div><div class="line">      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.</div><div class="line"></div><div class="line">ansible_ssh_private_key_file</div><div class="line">      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</div><div class="line"></div><div class="line">ansible_shell_type</div><div class="line">      目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.</div><div class="line"></div><div class="line">ansible_python_interpreter</div><div class="line">      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python</div><div class="line">      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).</div><div class="line"></div><div class="line">      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</div></pre></td></tr></table></figure></p>
<h3 id="运行第一个命令"><a href="#运行第一个命令" class="headerlink" title="运行第一个命令"></a>运行第一个命令</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible vm03 -m command -a &quot;hostname&quot;</div><div class="line">192.168.1.124 | success | rc=0 &gt;&gt;</div><div class="line">gy-vm03</div></pre></td></tr></table></figure></p>
<p>我们还可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible vm03:vm04 -m command -a &quot;hostname&quot;</div><div class="line">192.168.1.140 | success | rc=0 &gt;&gt;</div><div class="line">gy-vm04</div><div class="line"></div><div class="line">192.168.1.124 | success | rc=0 &gt;&gt;</div><div class="line">gy-vm03</div></pre></td></tr></table></figure></p>
<p>Ansible提供两种方式去完成任务,一是 ad-hoc 命令,一是写 Ansible playbook。前者可以解决一些简单的任务, 后者解决较复杂的任务。<br>如果我们敲入一些命令去比较快的完成一些事情,而不需要将这些执行的命令特别保存下来, 这样的命令就叫做 ad-hoc 命令。</p>
<h4 id="常用的一些模块"><a href="#常用的一些模块" class="headerlink" title="常用的一些模块"></a>常用的一些模块</h4><p><strong>setup</strong><br>用来查看远程主机的一些基本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible vm03 -m setup</div><div class="line">192.168.1.124 | success &gt;&gt; &#123;</div><div class="line">    &quot;ansible_facts&quot;: &#123;</div><div class="line">        &quot;ansible_all_ipv4_addresses&quot;: [</div><div class="line">            &quot;192.168.1.124&quot;, </div><div class="line">            &quot;192.168.168.13&quot;, </div><div class="line">            &quot;172.17.42.1&quot;</div><div class="line">        ], </div><div class="line">        &quot;ansible_all_ipv6_addresses&quot;: [</div><div class="line">            &quot;fe80::20c:29ff:fe39:c20d&quot;, </div><div class="line">            &quot;fe80::20c:29ff:fe39:c217&quot;, </div><div class="line">            &quot;fe80::d0cd:7dff:fe2c:3fb&quot;</div><div class="line">        ], </div><div class="line">        &quot;ansible_architecture&quot;: &quot;x86_64&quot;, </div><div class="line">        &quot;ansible_bios_date&quot;: &quot;07/02/2015&quot;, </div><div class="line">        &quot;ansible_bios_version&quot;: &quot;6.00&quot;, </div><div class="line">        &quot;ansible_cmdline&quot;: &#123;</div><div class="line">            &quot;KEYBOARDTYPE&quot;: &quot;pc&quot;, </div><div class="line">            &quot;KEYTABLE&quot;: &quot;us&quot;, </div><div class="line">            &quot;LANG&quot;: &quot;en_US.UTF-8&quot;, </div><div class="line">            &quot;SYSFONT&quot;: &quot;latarcyrheb-sun16&quot;, </div><div class="line">            &quot;quiet&quot;: true, </div><div class="line">            &quot;rd_NO_DM&quot;: true, </div><div class="line">            &quot;rd_NO_LUKS&quot;: true, </div><div class="line">            &quot;rd_NO_LVM&quot;: true, </div><div class="line">            &quot;rd_NO_MD&quot;: true, </div><div class="line">            &quot;rhgb&quot;: true, </div><div class="line">            &quot;ro&quot;: true, </div><div class="line">            &quot;root&quot;: &quot;UUID=1bfa6437-81b1-4288-acb9-1c5ff1532d03&quot;</div><div class="line">        &#125;,</div></pre></td></tr></table></figure></p>
<p><strong>ping</strong><br>用来测试远程主机的运行状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible all -m ping</div><div class="line">192.168.1.108 | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: false, </div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">192.168.1.140 | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: false, </div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">192.168.1.124 | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: false, </div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>file</strong><br>设置文件的属性<br>force：需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no<br>group：定义文件/目录的属组<br>mode：定义文件/目录的权限<br>owner：定义文件/目录的属主<br>path：必选项，定义文件/目录的路径<br>recurse：递归设置文件的属性，只对目录有效<br>src：被链接的源文件路径，只应用于state=link的情况<br>dest：被链接到的路径，只应用于state=link的情况<br>state：<br>       directory：如果目录不存在，就创建目录<br>       file：即使文件不存在，也不会被创建<br>       link：创建软链接<br>       hard：创建硬链接<br>       touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间<br>       absent：删除目录、文件或者取消链接文件</p>
<p><strong>copy</strong><br>复制文件到远程主机<br>相关选项如下：<br>backup：在覆盖之前，将源文件备份，备份文件包含时间信息。有两个选项：yes|no<br>content：用于替代“src”，可以直接设定指定文件的值<br>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录<br>directory_mode：递归设定目录的权限，默认为系统默认权限<br>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes<br>others：所有的file模块里的选项都可以在这里使用<br>src：被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用“/”来结尾，则只复制目录里的内容，如果没有使用“/”来结尾，则包含目录在内的整个内容全部复制，类似于rsync。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible vm03 -m copy -a &quot;src=/home/ggyy/vm02.txt dest=/tmp/vm02.txt owner=ggyy group=ggyy mode=0644&quot; </div><div class="line">192.168.1.124 | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: true, </div><div class="line">    &quot;checksum&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;, </div><div class="line">    &quot;dest&quot;: &quot;/tmp/vm02.txt&quot;, </div><div class="line">    &quot;gid&quot;: 500, </div><div class="line">    &quot;group&quot;: &quot;ggyy&quot;, </div><div class="line">    &quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;, </div><div class="line">    &quot;mode&quot;: &quot;0644&quot;, </div><div class="line">    &quot;owner&quot;: &quot;ggyy&quot;, </div><div class="line">    &quot;secontext&quot;: &quot;unconfined_u:object_r:user_home_t:s0&quot;, </div><div class="line">    &quot;size&quot;: 0, </div><div class="line">    &quot;src&quot;: &quot;/home/ggyy/.ansible/tmp/ansible-tmp-1461489632.3-235226806263683/source&quot;, </div><div class="line">    &quot;state&quot;: &quot;file&quot;, </div><div class="line">    &quot;uid&quot;: 500</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible vm03 -m command -a &quot;ls /tmp/vm02.txt -l&quot;</div><div class="line">192.168.1.124 | success | rc=0 &gt;&gt;</div><div class="line">-rw-r--r--. 1 ggyy ggyy 0 Apr 24 17:19 /tmp/vm02.txt</div></pre></td></tr></table></figure>
<p><strong>command</strong><br>在远程主机上执行命令,默认模块<br>相关选项如下：<br>creates：一个文件名，当该文件存在，则该命令不执行<br>free_form：要执行的linux指令<br>chdir：在执行指令之前，先切换到该目录<br>removes：一个文件名，当该文件不存在，则该选项不执行<br>executable：切换shell来执行指令，该执行路径必须是一个绝对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible all -m command -a &quot;date&quot;</div><div class="line">192.168.1.108 | success | rc=0 &gt;&gt;</div><div class="line">Sun Apr 24 17:23:12 CST 2016</div><div class="line"></div><div class="line">192.168.1.140 | success | rc=0 &gt;&gt;</div><div class="line">Sun Apr 24 17:22:50 CST 2016</div><div class="line"></div><div class="line">192.168.1.124 | success | rc=0 &gt;&gt;</div><div class="line">Sun Apr 24 17:23:10 CST 2016</div></pre></td></tr></table></figure></p>
<p><strong>shell</strong><br>切换到某个shell执行指定的指令，参数与command相同。<br>与command不同的是，此模块可以支持命令管道，同时还有另一个模块也具备此功能：raw<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible all -m shell -a &quot;ps aux | grep ntpd&quot;</div><div class="line">192.168.1.108 | success | rc=0 &gt;&gt;</div><div class="line">ntp        786  0.0  0.2  29396  2028 ?        Ss   16:34   0:00 /usr/sbin/ntpd -u ntp:ntp -g</div><div class="line">root      2816  0.0  0.1   9508  1144 pts/0    S+   17:25   0:00 /bin/sh -c ps aux | grep ntpd</div><div class="line">root      2818  0.0  0.0   9040   672 pts/0    S+   17:25   0:00 grep ntpd</div><div class="line"></div><div class="line">192.168.1.140 | success | rc=0 &gt;&gt;</div><div class="line">ggyy      3358  0.0  0.1   9232  1032 pts/0    S+   17:24   0:00 /bin/sh -c ps aux | grep ntpd</div><div class="line">ggyy      3360  0.0  0.0   6388   664 pts/0    S+   17:24   0:00 grep ntpd</div><div class="line"></div><div class="line">192.168.1.124 | success | rc=0 &gt;&gt;</div><div class="line">ggyy      4717  0.0  0.1   9232  1032 pts/1    S+   17:25   0:00 /bin/sh -c ps aux | grep ntpd</div><div class="line">ggyy      4719  0.0  0.0   6388   660 pts/1    S+   17:25   0:00 grep ntpd</div></pre></td></tr></table></figure></p>
<p><strong>更多模块</strong><br>更多模块请参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm02 ~]$ ansible-doc -l</div></pre></td></tr></table></figure></p>
<p>好了，关于ansible的入门基础就讲到这里，下一节，我们来深入了解Playbooks。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/24/ansible/" data-id="ciu2e80er00027rhpz6obtc1c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iptables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/iptables/" class="article-date">
  <time datetime="2016-04-16T16:00:00.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/iptables/">Linux 的封包过滤软件--iptables</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iptables，对于接触过linux的人来说，对这个概念不会感到陌生。它是linux系统自带的一款软件防火墙。以前我一直对这个知识点掌握的比较零散，今天决定系统的来学习一下。早期的linux并不是使用iptables，在内核版本2.0是使用的 ipfwadm 这个防火墙机制，在内核版本2.2是ipchains 这个防火墙机制，在内核版本2.6之后就是使用的iptables了。</p>
<p>了解了它的发展史，接下来进入正题。</p>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>iptables 是利用封包过滤的机制， 所以他会分析封包的表头数据。根据表头数据与定义的规则来决定该封包是否可以进入主机或者是被丢弃。 意思就是说：根据封包的分析资料 “比对” 你预先定义的规则内容， 若封包数据与规则内容相同则进行动作，否则就继续下一条规则的比对！<br>所以，重点就在比对与分析顺序上。</p>
<h3 id="iptables的表格-table-与链-chain"><a href="#iptables的表格-table-与链-chain" class="headerlink" title="iptables的表格 (table) 与链 (chain)"></a>iptables的表格 (table) 与链 (chain)</h3><p>Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用) ，表格和链的用途分别是这样的</p>
<p><strong>filter (过滤器)</strong><br>主要跟进入 Linux 本机的封包有关，这个是预设的 table</p>
<ul>
<li>INPUT：主要与想要进入我们 Linux 本机的封包有关</li>
<li>OUTPUT：主要与我们 Linux 本机所要送出的封包有关</li>
<li>FORWARD：这个咚咚与 Linux 本机比较没有关系， 他可以转递封包到后端的计算机中，与下列 nat table 相关性较高</li>
</ul>
<p><strong>nat (地址转换)</strong><br>是 Network Address Translation 的缩写， 这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与 Linux 主机后的局域网络内计算机较有相关</p>
<ul>
<li>PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</li>
<li>POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</li>
<li>OUTPUT：与发送出去的封包有关</li>
</ul>
<p><strong>mangle (破坏者)</strong><br>这个表格主要是与特殊的封包的路由旗标有关， 早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT 及 FORWARD 链。 由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格</p>
<h3 id="iptables-语法"><a href="#iptables-语法" class="headerlink" title="iptables 语法"></a>iptables 语法</h3><p>了解了概念性的知识，我来进入实战。我们在安装好linux系统之后，系统会自动启动一个防火墙规则，不过这个可能不是我们想要的模式，因此我们需要额外进行一些修订的行为。不过，我们在进行练习的过程中，最好不要在远程的机器上面进行操作，因为 iptables 的指令会将网络封包进行过滤及抵挡的动作，你很有可能一不小心将自己关在家门外。</p>
<h4 id="查看与清除iptables规则"><a href="#查看与清除iptables规则" class="headerlink" title="查看与清除iptables规则"></a>查看与清除iptables规则</h4><p><strong>查看语法</strong><br>iptables [-t tables] [-L] [-nv]<br>选项与参数：<br>-t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的 filter<br>-L ：列出目前的 table 的规则<br>-n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！<br>-v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等<br>例如查看本机的防火墙规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -L -n</div><div class="line">Chain INPUT (policy ACCEPT) //针对 INPUT 链，且预设政策为可接受</div><div class="line">target     prot opt source  //说明栏              destination         </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED  //第 1 条规则</div><div class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0 //第 2 条规则        </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0 //第 3 条规则  以下类推   </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22  </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:80  </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:443 </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT) //针对 FORWARD 链，且预设政策为可接受</div><div class="line">target     prot opt source               destination         </div><div class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           ctstate RELATED,ESTABLISHED </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT) //针对 OUTPUT 链，且预设政策为可接受</div><div class="line">target     prot opt source               destination         </div><div class="line"></div><div class="line">Chain DOCKER (1 references) //这是关于docker的自定义链</div><div class="line">target     prot opt source               destination         </div><div class="line">[root@gy-vm04 ~]#</div></pre></td></tr></table></figure></p>
<p>如果要查看关于nat 的table规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -t nat -L -n</div><div class="line">Chain PREROUTING (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           ADDRTYPE match dst-type LOCAL </div><div class="line"></div><div class="line">Chain POSTROUTING (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           </div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8         ADDRTYPE match dst-type LOCAL </div><div class="line"></div><div class="line">Chain DOCKER (2 references)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure></p>
<p>上面的每一个Chain就是所谓的链，Chain 那一行里面括号的 policy 就是预设的政策，什么是policy，就是当一个封包不匹配所有的规则，就默认执行这个政策。其他的参数说明</p>
<ul>
<li>target：代表进行的动作， ACCEPT 是放行，而 - REJECT 则是拒绝，此外，尚有 DROP (丢弃) 的项目！</li>
<li>prot：代表使用的封包协议，主要有 tcp, udp 及 icmp 三种封包格式；</li>
<li>opt：额外的选项说明</li>
<li>source ：代表此规则是针对哪个来源 IP进行限制？</li>
<li>destination ：代表此规则是针对哪个目标 IP进行限制？</li>
</ul>
<p><strong>清除规则</strong><br>如何删除默认的规则，来建立我们自己想要定义的规则了。<br>语法：<br>iptables [-t tables] [-FXZ]<br>选项与参数：<br>-F ：清除所有的已订定的规则；<br>-X ：杀掉所有使用者 “自定义” 的 chain (应该说的是 tables ）啰；<br>-Z ：将所有的 chain 的计数与流量统计都归零</p>
<p><strong><em>切记</em></strong><br>这个操作一定要小心，这三个指令会将本机防火墙的所有规则都清除，但却不会改变预设政策 (policy) ， 所以如果你不是在本机下达这三行指令时，很可能你会被自己挡在家门外</p>
<h4 id="定义预设policy（政策）"><a href="#定义预设policy（政策）" class="headerlink" title="定义预设policy（政策）"></a>定义预设policy（政策）</h4><p>语法：<br> iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]<br> 选项与参数：<br>-P ：定义政策( Policy )。注意，这个 P 为大写啊！<br>ACCEPT ：该封包可接受<br>DROP   ：该封包直接丢弃，不会让 client 端知道为何被丢弃。<br>例如将本机的INPUT 设定为 DROP ，其他设定为 ACCEPT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -P INPUT DROP</div><div class="line">[root@gy-vm04 ~]# iptables -P OUTPUT  ACCEPT</div><div class="line">[root@gy-vm04 ~]# iptables -P FORWARD ACCEPT</div></pre></td></tr></table></figure></p>
<p><strong>tips</strong><br>我们在修改完规则之后，记得使用iptables-save这条命名保存，不然的话，我们以后在重启iptables的服务之后，规则就不存在了。</p>
<h4 id="针对IP已经网口的设置"><a href="#针对IP已经网口的设置" class="headerlink" title="针对IP已经网口的设置"></a>针对IP已经网口的设置</h4><p>语法：<br> iptables [-AI 链名] [-io 网络接口] [-p 协议]  [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</p>
<p>选项与参数：<br>-AI 链名：针对某的链进行规则的 “插入” 或 “累加”<br>    -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，<br>         使用 -A 就可以加上第五条规则！<br>    -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。<br>         例如原本有四条规则，使用 -I 则该规则变成第一条，而原本四条变成 2~5 号<br>    链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</p>
<p>-io 网络接口：设定封包进出的接口规范<br>    -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；<br>    -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</p>
<p>-p 协定：设定此规则适用于哪种封包格式<br>   主要的封包格式有： tcp, udp, icmp 及 all 。</p>
<p>-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：<br>   IP  ：192.168.0.100<br>   网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。<br>   若规范为『不许』时，则加上 ! 即可，例如：<br>   -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</p>
<p>-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</p>
<p>-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</p>
<p>例如我们对于lo接口所有封包添加为接受<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -i lo -j ACCEPT</div></pre></td></tr></table></figure></p>
<p><strong>tips</strong><br>如果没有没有列出 -s, -d 等等的规则，这表示：不论封包来自何处或去到哪里，只要是来自 lo 这个接口，就予以接受！</p>
<p>由于我比较喜欢使用Xshell登录来操作虚拟机，所以一般会把我本机的IP添加为ACCEPT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -s 192.168.168.2 -j ACCEPT</div></pre></td></tr></table></figure></p>
<p>这样我才能登录到这台虚拟机上面去。</p>
<h4 id="针对端口的设定"><a href="#针对端口的设定" class="headerlink" title="针对端口的设定"></a>针对端口的设定</h4><p>语法：<br>iptables [-AI 链] [-io 网络接口] [-p tcp,udp]  [-s 来源IP/网域] [–sport 端口范围] [-d 目标IP/网域] [–dport 端口范围] -j [ACCEPT|DROP|REJECT]<br>例如：<br>打开eth0上的8080端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -i eht0  --dport 8080 -j ACCEPT</div><div class="line">iptables v1.4.7: unknown option `--dport&apos;</div><div class="line">Try `iptables -h&apos; or &apos;iptables --help&apos; for more information.</div></pre></td></tr></table></figure></p>
<p>额，怎么报错了，提示不知道参数–dport。<br>这是因为仅有 tcp 与 udp 封包具有端口，因此你想要使用 –dport, –sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功<br>正确的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -i eht0 -p tcp --dport 8080 -j ACCEPT</div></pre></td></tr></table></figure></p>
<p><strong>tips</strong><br>我们可以指定连续的端口<br>例如：–dport 1000:2000</p>
<h4 id="iptables-外挂模块：mac-与-state"><a href="#iptables-外挂模块：mac-与-state" class="headerlink" title="iptables 外挂模块：mac 与 state"></a>iptables 外挂模块：mac 与 state</h4><p>语法：<br> iptables -A INPUT [-m state] [–state 状态]<br> 选项与参数：<br>-m ：一些 iptables 的外挂模块，主要常见的有：<br>     state ：状态模块<br>     mac   ：网络卡硬件地址 (hardware address)<br>–state ：一些封包的状态，主要有：<br>     INVALID    ：无效的封包，例如数据破损的封包状态<br>     ESTABLISHED：已经联机成功的联机状态；<br>     NEW        ：想要新建立联机的封包状态；<br>     RELATED    ：这个最常用！表示这个封包是与我们主机发送出去的封包有关</p>
<p>例如：<br>只要已建立或相关封包就予以通过，只要是不合法封包就丢弃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class="line">[root@gy-vm04 ~]# iptables -A INPUT -m state --state INVALID -j DROP</div></pre></td></tr></table></figure></p>
<p>iptables还可以针对网卡来进行放行与防御<br>语法：<br>iptables -A INPUT -m mac –mac-source aa:bb:cc:dd:ee:ff -j ACCEPT<br>选项与参数：<br>–mac-source ：就是来源主机的 MAC</p>
<h4 id="ICMP-封包规则"><a href="#ICMP-封包规则" class="headerlink" title="ICMP 封包规则"></a>ICMP 封包规则</h4><p>语法：<br>iptables -A INPUT [-p icmp] [–icmp-type 类型] -j ACCEPT<br>选项与参数：<br>–icmp-type ：后面必须要接 ICMP 的封包类型，也可以使用代号，例如 8  代表 echo request 的意思。<br>默认系统是对所有类型都ACCEPT</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/17/iptables/" data-id="ciu2e80f9000d7rhphgrwr1ql" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ddos" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/ddos/" class="article-date">
  <time datetime="2016-04-02T16:00:00.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/ddos/">Linux防DDOS攻击软件--DDoS-Deflate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/jgmdev/ddos-deflate" target="_blank" rel="external">DDoS-Deflate</a>是一款免费的用来防御和减轻DDoS攻击的脚本。它通过netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过预设的限制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.<br>这个工具对大量模拟的假IP地址效果不是很明显</p>
<p>如何确认是否受到DDOS攻击？<br>使用下面这条命令进行查看<br>netstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sort | uniq -c | sort -n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[bhuser@boohee-rc ~]$ netstat -ntu | awk &apos;&#123;print $5&#125;&apos; | cut -d: -f1 | sort | uniq -c | sort -n</div><div class="line">      1 101.200.31.129</div><div class="line">      1 101.200.31.147</div><div class="line">      1 103.240.124.9</div><div class="line">      1 192.168.1.18</div><div class="line">      1 64.125.239.126</div><div class="line">      1 Address</div><div class="line">      1 servers)</div><div class="line">      2 114.114.114.114</div><div class="line">      2 192.168.1.64</div><div class="line">      2 210.22.84.3</div><div class="line">      2 58.246.136.4</div><div class="line">      8 192.168.1.51</div><div class="line">     16 192.168.1.16</div><div class="line">     63 </div><div class="line">     91 192.168.1.20</div><div class="line">    107 192.168.1.44</div><div class="line">    243 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>每个IP(内网IP除外)几个、十几个或几十个连接数都还算比较正常，如果某个IP连接数有几百上千就是攻击了。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用root用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/jgmdev/ddos-deflate/archive/master.zip</div><div class="line">unzip master.zip</div><div class="line">cd ddos-deflate-master</div><div class="line">./install.sh</div></pre></td></tr></table></figure></p>
<p>在执行install.sh可能会提示如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ddos-deflate-master]# ./install.sh </div><div class="line">which: no tcpkill in (/usr/lib/jvm/java-7-oracle/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)</div><div class="line">error: Required dependency &apos;tcpkill&apos; is missing.</div></pre></td></tr></table></figure></p>
<p><strong><em>tcpkill</em></strong><br>当遇到TCP链接迟迟不能释放的情况，类似FIN_WAIT1、FIN_WAIT2的状态，释放时间不确定，而且对应的程序已经关闭，相应的端口也不再监听，无法通过杀进程来解决，这种情况下，为了快速恢复正常，不得不采用重启服务器的方法加以解决，Linux下可以借助dsniff包中含有tcpkill命令，该命令可以将上述状态的TCP链接加以清除</p>
<p><strong><em>下载dsniff rpm包</em></strong><br>wget <a href="http://mirrors.zju.edu.cn/epel/6/x86_64/libnet-1.1.6-7.el6.x86_64.rpm" target="_blank" rel="external">http://mirrors.zju.edu.cn/epel/6/x86_64/libnet-1.1.6-7.el6.x86_64.rpm</a><br>wget <a href="http://mirrors.zju.edu.cn/epel/6/x86_64/libnids-1.24-1.el6.x86_64.rpm" target="_blank" rel="external">http://mirrors.zju.edu.cn/epel/6/x86_64/libnids-1.24-1.el6.x86_64.rpm</a><br>wget <a href="http://mirrors.zju.edu.cn/epel/6/x86_64/dsniff-2.4-0.17.b1.el6.x86_64.rpm" target="_blank" rel="external">http://mirrors.zju.edu.cn/epel/6/x86_64/dsniff-2.4-0.17.b1.el6.x86_64.rpm</a><br>其中libnet和libnids是两个依赖包</p>
<p>再次执行install.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ddos-deflate-master]# ./install.sh </div><div class="line"></div><div class="line">Installing DOS-Deflate 0.8</div><div class="line"></div><div class="line">Adding: /etc/ddos/ddos.conf... (done)</div><div class="line">Adding: /etc/ddos/ignore.ip.list... (done)</div><div class="line">Adding: /etc/ddos/ignore.host.list... (done)</div><div class="line">Adding: /usr/local/ddos/LICENSE... (done)</div><div class="line">Adding: /usr/local/ddos/ddos.sh... (done)</div><div class="line">Creating ddos script: /usr/local/sbin/ddos... (done)</div><div class="line">Adding man page... (done)</div><div class="line">Adding logrotate configuration... (done)</div><div class="line"></div><div class="line">Setting up init script... (done)</div><div class="line">Activating ddos service... (done)</div><div class="line"></div><div class="line">Installation has completed!</div><div class="line">Config files are located at /etc/ddos/</div><div class="line"></div><div class="line">Please send in your comments and/or suggestions to:</div><div class="line">https://github.com/jgmdev/ddos-deflate/issues</div></pre></td></tr></table></figure></p>
<p>可以看到，主要配置文件在/etc/ddos/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ddos]# cd /etc/ddos/</div><div class="line">[root@gy-vm03 ddos]# ls</div><div class="line">ddos.conf  ignore.host.list  ignore.ip.list</div><div class="line">[root@gy-vm03 ddos]#</div></pre></td></tr></table></figure></p>
<p>ddos.conf是主配置文件<br>ignore.host.list 你可以添加主机名到这个文件里面做为白名单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">boohee.com</div><div class="line">www.boohee.com</div></pre></td></tr></table></figure>
<p>ignore.ip.list  你可以添加IP到这个文件里面做为白名单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.1.20</div></pre></td></tr></table></figure>
<p>安装完成之后，系统默认启动了ddos<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ddos]# ps aux | grep ddos</div><div class="line">root      2616  0.1  0.1  11472  1456 pts/0    S    20:34   0:01 /bin/bash /usr/local/ddos/ddos.sh -l</div><div class="line">root      5945  0.0  0.0 103252   836 pts/0    S+   20:48   0:00 grep ddos</div><div class="line">[root@gy-vm03 ddos]#</div></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>ddos.conf是它的主配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># Paths of the script and other files</div><div class="line">PROGDIR=&quot;/usr/local/ddos&quot; </div><div class="line">SBINDIR=&quot;/usr/local/sbin&quot;</div><div class="line">PROG=&quot;$PROGDIR/ddos.sh&quot;</div><div class="line">IGNORE_IP_LIST=&quot;ignore.ip.list&quot;</div><div class="line">IGNORE_HOST_LIST=&quot;ignore.host.list&quot;</div><div class="line">CRON=&quot;/etc/cron.d/ddos&quot;</div><div class="line"># Make sure your APF version is atleast 0.96</div><div class="line">APF=&quot;/usr/sbin/apf&quot;</div><div class="line">CSF=&quot;/usr/sbin/csf&quot;</div><div class="line">IPT=&quot;/sbin/iptables&quot;</div><div class="line"></div><div class="line"># frequency in minutes for running the script as a cron job</div><div class="line"># Caution: Every time this setting is changed, run the script with --cron</div><div class="line">#          option so that the new frequency takes effect</div><div class="line">FREQ=1  //检查时间间隔，默认1分钟</div><div class="line"></div><div class="line"># frequency in seconds when running as a daemon</div><div class="line">DAEMON_FREQ=5</div><div class="line"></div><div class="line"># How many connections define a bad IP? Indicate that below.</div><div class="line">NO_OF_CONNECTIONS=150 //最大连接数，超过这个数IP就会被屏蔽，默认150</div><div class="line"></div><div class="line"># The firewall to use for blocking/unblocking, valid values are:</div><div class="line"># auto, apf, csf and iptables</div><div class="line">FIREWALL=&quot;iptables&quot;</div><div class="line"></div><div class="line"># An email is sent to the following address when an IP is banned.</div><div class="line"># Blank would suppress sending of mails</div><div class="line">EMAIL_TO=&quot;root&quot; //当IP被屏蔽时给指定邮箱发送邮件，推荐使用，换成自己的邮箱即可</div><div class="line"></div><div class="line"># Number of seconds the banned ip should remain in blacklist.</div><div class="line">BAN_PERIOD=600 //禁用IP留在黑名单中的时间，默认600秒，可根据情况调整</div><div class="line"></div><div class="line"># Connection states to block. See: man netstat</div><div class="line">CONN_STATES=&quot;ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE_WAIT|LAST_ACK|CLOSING&quot;</div></pre></td></tr></table></figure></p>
<p>这个软件的关键程序就是这个ddos.sh脚本，原理是利用cron定时执行一次ddos.sh脚本，而ddos.sh通过执行netstat命令获取到异常的IP列表，添加到iptables中去。</p>
<p><strong>tips：</strong><br><strong>crontab任务是要执行ddos -c来创建的，更多参数请执行ddos –help查看</strong></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里我们使用ab测试工具来检验一下<br>测试用到下面两台虚拟机<br>192.168.1.105  vm02 安装了ddos-deflate，并且是nginx服务器<br>192.168.1.104  vm03 测试机器<br>首先在vm03上面正常访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ~]# curl -I ban1.gy.com</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: Tengine/2.1.0</div><div class="line">Date: Sun, 03 Apr 2016 13:13:53 GMT</div><div class="line">Content-Type: text/html</div><div class="line">Content-Length: 5</div><div class="line">Last-Modified: Mon, 30 Nov 2015 17:18:12 GMT</div><div class="line">Connection: keep-alive</div><div class="line">ETag: &quot;565c84d4-5&quot;</div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure></p>
<p>接下来在vm03上面使用ab测试工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ~]# ab -c 1 -n 100 http://ban1.gy.com/inex.html</div></pre></td></tr></table></figure></p>
<p>然后再到vm02上面查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# netstat -ntu | awk &apos;&#123;print $5&#125;&apos; | cut -d: -f1 | sort | uniq -c | sort -n</div><div class="line">      1 192.168.168.1</div><div class="line">      1 Address</div><div class="line">      1 servers)</div><div class="line">    100 192.168.10.104</div></pre></td></tr></table></figure></p>
<p>使用iptable查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# iptables -L -n</div><div class="line">Chain INPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </div><div class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:873 </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:80 </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           ctstate RELATED,ESTABLISHED </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line"></div><div class="line">Chain DOCKER (1 references)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure></p>
<p>此时并没有添加进来</p>
<p>再次到vm03上面测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm03 ~]# ab -c 1 -n 300 http://ban1.gy.com/inex.html</div></pre></td></tr></table></figure></p>
<p>然后到vm02上面进行查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# iptables -L -n</div><div class="line">Chain INPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">DROP       all  --  192.168.10.104       0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </div><div class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:873 </div><div class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:80 </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           ctstate RELATED,ESTABLISHED </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </div><div class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line"></div><div class="line">Chain DOCKER (1 references)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure></p>
<p>此时192.168.10.104被添加了进来<br>并且在bhvm02上面查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm02 ~]# tail /var/log/ddos.log </div><div class="line">[2016-03-29 20:02:28] daemon started</div><div class="line">[2016-03-29 20:02:50] banned 192.168.1.124 with 13557 connections for ban period 600</div><div class="line">[2016-03-29 20:12:55] unbanned 192.168.1.124</div><div class="line">[2016-03-29 20:13:00] banned 192.168.1.124 with 600 connections for ban period 600</div><div class="line">[2016-03-29 20:23:17] unbanned 192.168.1.124</div><div class="line">[2016-03-29 23:31:56] daemon started</div><div class="line">[2016-03-30 09:50:37] daemon started</div><div class="line">[2016-04-03 21:12:23] added cron job</div><div class="line">[2016-04-03 21:22:06] daemon started</div><div class="line">[2016-04-03 21:22:06] banned 192.168.10.104 with 900 connections for ban period 200</div><div class="line">[root@gy-vm02 ~]#</div></pre></td></tr></table></figure></p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ddos-deflate-master</div><div class="line">./uninstall.sh</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/ddos/" data-id="ciu2e80ev00057rhpnhfw6qqt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux-file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/27/linux-file/" class="article-date">
  <time datetime="2016-03-26T16:00:00.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/linux-file/">linux 文件时间atime、mtime、ctime</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>对于linux文件系统中的文件和目录，有三种时间状态atime、mtime和ctime，他们分别代表的意思是：<br><strong><em>atime：access time</em></strong><br>访问时间，读一次这个文件的内容，这个时间就会更新。比如对这个文件运用 more、cat等命令。ls、stat命令都不会修改文件的访问时间。<br><strong><em>mtime：modified time</em></strong><br>修改时间，修改时间是文件内容最后一次被修改时间。比如：vi后保存文件。ls -l列出的时间就是这个时间。<br><strong><em>ctime：change time</em></strong><br>状态改动时间。是该文件的inode节点最后一次被修改的时间，通过chmod、chown命令修改一次文件属性，这个时间就会更新。</p>
<p><strong>如何查看atime、mtime和ctime</strong><br>ls -lu filename         列出文件的 atime<br>ls -l  filename          列出文件的 mtime<br>ls -lc filename         列出文件的 ctime<br>也可以使用stat filename来同时查看三个时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm03 ~]$ stat 1.txt </div><div class="line">  File: `1.txt&apos;</div><div class="line">  Size: 11        	Blocks: 8          IO Block: 4096   regular file</div><div class="line">Device: 802h/2050d	Inode: 394206      Links: 1</div><div class="line">Access: (0664/-rw-rw-r--)  Uid: (  500/    ggyy)   Gid: (  500/    ggyy)</div><div class="line">Access: 2016-03-27 00:09:04.196004991 +0800</div><div class="line">Modify: 2016-03-27 00:08:48.150005058 +0800</div><div class="line">Change: 2016-03-27 00:08:48.150005058 +0800</div></pre></td></tr></table></figure></p>
<p>在linux中stat函数中，用st_atime表示文件数据最近的存取时间(last accessed time)；用st_mtime表示文件数据最近的修改时间(last modified time)；使用st_ctime表示文件i节点数据最近的修改时间(last i-node’s status changed time)。</p>
<p> 字段           说明                  例子           ls(-l)<br> st_atime  文件数据的最后存取时间       read            -u<br> st_mtime  文件数据的最后修改时间       write           缺省<br> st_ctime  文件数据的最后更改时间       chown,chmod     -c</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h4><p>有时候我们会发现，即是访问了文件，该文件的访问时间也不会变，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm03 ~]$ stat 1.txt </div><div class="line">  File: `1.txt&apos;</div><div class="line">  Size: 5         	Blocks: 8          IO Block: 4096   regular file</div><div class="line">Device: 802h/2050d	Inode: 394206      Links: 1</div><div class="line">Access: (0664/-rw-rw-r--)  Uid: (  500/    ggyy)   Gid: (  500/    ggyy)</div><div class="line">Access: 2016-03-27 00:01:09.379005522 +0800</div><div class="line">Modify: 2016-03-26 23:27:18.032007859 +0800</div><div class="line">Change: 2016-03-26 23:27:18.032007859 +0800</div><div class="line">[ggyy@gy-vm03 ~]$ cat 1.txt </div><div class="line">test</div><div class="line">[ggyy@gy-vm03 ~]$ stat 1.txt </div><div class="line">  File: `1.txt&apos;</div><div class="line">  Size: 5         	Blocks: 8          IO Block: 4096   regular file</div><div class="line">Device: 802h/2050d	Inode: 394206      Links: 1</div><div class="line">Access: (0664/-rw-rw-r--)  Uid: (  500/    ggyy)   Gid: (  500/    ggyy)</div><div class="line">Access: 2016-03-27 00:01:09.379005522 +0800</div><div class="line">Modify: 2016-03-26 23:27:18.032007859 +0800</div><div class="line">Change: 2016-03-26 23:27:18.032007859 +0800</div><div class="line">[ggyy@gy-vm03 ~]$</div></pre></td></tr></table></figure></p>
<p>其原因是kernel更新文件访问时间是有策略的，其策略经过了三个发展阶段</p>
<ul>
<li><p>初始阶段<br>linux总是实时更新访问时间的，但这会涉及到大量的写磁盘操作，严重影响到linux性能。</p>
</li>
<li><p>第二阶段<br>考虑到1的缺陷，可以在挂载文件系统时使用noatime属性来停止更新atime。但这会对许多应用程序造成影响，比如邮箱，备份软件，时间同步工具</p>
</li>
<li><p>第三阶段<br>综合1,2，现在的linux使用了折中方案，挂载文件系统时使用的默认属性为relatime。其更新策略为：当满足以下任一条件时才更新访问时间，<br>1、访问时间早于修改时间或改变状态时间<br>2、距离上次更新时间间隔大于24h</p>
</li>
</ul>
<p>综上所叙：当访问时间大于修改时间和改变时间时，且距离上次更新时间小于24h时，访问时间不再更新，这就是造成上述访问时间不变的原因。</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h4><p>有时候，我们会发现某一文件的访问时间甚至比修改时间还要早，如下所示，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[ggyy@gy-vm03 ~]$ stat 1.txt </div><div class="line">  File: `1.txt&apos;</div><div class="line">  Size: 11        	Blocks: 8          IO Block: 4096   regular file</div><div class="line">Device: 802h/2050d	Inode: 394206      Links: 1</div><div class="line">Access: (0664/-rw-rw-r--)  Uid: (  500/    ggyy)   Gid: (  500/    ggyy)</div><div class="line">Access: 2016-03-27 00:09:04.196004991 +0800</div><div class="line">Modify: 2016-03-27 00:08:48.150005058 +0800</div><div class="line">Change: 2016-03-27 00:08:48.150005058 +0800</div><div class="line">[ggyy@gy-vm03 ~]$ echo &quot;1122&quot; &gt;&gt; 1.txt </div><div class="line">[ggyy@gy-vm03 ~]$ stat 1.txt </div><div class="line">  File: `1.txt&apos;</div><div class="line">  Size: 16        	Blocks: 8          IO Block: 4096   regular file</div><div class="line">Device: 802h/2050d	Inode: 394206      Links: 1</div><div class="line">Access: (0664/-rw-rw-r--)  Uid: (  500/    ggyy)   Gid: (  500/    ggyy)</div><div class="line">Access: 2016-03-27 00:09:04.196004991 +0800</div><div class="line">Modify: 2016-03-27 00:35:04.421003193 +0800</div><div class="line">Change: 2016-03-27 00:35:04.421003193 +0800</div><div class="line">[ggyy@gy-vm03 ~]$</div></pre></td></tr></table></figure></p>
<p>这是因为在修改文件的操作中，有的会访问到该文件，有的不会。</p>
<ul>
<li><p>比如，使用命令vim file修改文件,同时也访问了该文件。所以，修改完后首先更新文件的修改时间，接着更新访问时间。由于此时的访问时间已经小于新的修改时间，所以更新访问时间到与修改时间相同。</p>
</li>
<li><p>使用命令echo “1122” &gt;&gt; 1.txt，此命令仅仅修改了文件，并没有访问，故仅更新修改时间，访问时间因为没变而晚于修改时间，此即上述现象产生的原因。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/27/linux-file/" data-id="ciu2e80fb000e7rhp6m9f275a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/nginx/" class="article-date">
  <time datetime="2016-03-19T16:00:00.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/nginx/">nginx防止DDOS攻击配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近查看服务器nginx日志，看到很多类似DDos攻击的IP被nginx拦截了。<br>DDos全称分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。<br>DDOS的特点是分布式，针对带宽和服务攻击，也就是四层流量攻击和七层应用攻击，相应的防御瓶颈四层在带宽，七层的多在架构的吞吐量。对于七层的应用攻击，我们还是可以做一些配置来防御的，例如前端是Nginx，主要使用nginx的http_limit_conn和http_limit_req模块来防御。<br>ngx_http_limit_conn_module 可以限制单个IP的连接数，ngx_http_limit_req_module 可以限制单个IP每秒请求数，通过限制连接数和请求数能相对有效的防御CC攻击。</p>
<h3 id="限制每秒请求数"><a href="#限制每秒请求数" class="headerlink" title="限制每秒请求数"></a>限制每秒请求数</h3><p>ngx_http_limit_req_module模块通过漏桶原理来限制单位时间内的请求数，一旦单位时间内请求数超过限制，就会返回503错误。配置需要在两个地方设置：</p>
<ul>
<li>nginx.conf的http段内定义触发条件，可以有多个条件</li>
<li>在location内定义达到触发条件时nginx所要执行的动作</li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_req_zone $limit zone=one:10m rate=20r/s; //触发条件，所有访问ip 限制每秒10个请求</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        location  ~ \.php$ &#123;</div><div class="line">            limit_req zone=one burst=5 nodelay;   //执行的动作,通过zone名字对应</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p><strong>参数说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$binary_remote_addr  二进制远程地址</div><div class="line">zone=one:10m    定义zone名字叫one，并为这个zone分配10M内存，用来存储会话（二进制远程地址），1m内存可以保存16000会话</div><div class="line">rate=20r/s;     限制频率为每秒20个请求</div><div class="line">burst=5         允许超过频率限制的请求数不多于5个，假设1、2、3、4秒请求为每秒9个，那么第5秒内请求15个是允许的，反之，如果第一秒内请求15个，会将5个请求放到第二秒，第二秒内超过10的请求直接503，类似多秒内平均速率限制。</div><div class="line">nodelay         超过的请求不被延迟处理，设置后15个请求在1秒内处理。</div></pre></td></tr></table></figure></p>
<h3 id="限制IP连接数"><a href="#限制IP连接数" class="headerlink" title="限制IP连接数"></a>限制IP连接数</h3><p>ngx_http_limit_conn_module的配置方法和参数与http_limit_req模块很像，参数少，要简单很多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_conn_zone $binary_remote_addr zone=addr:10m; //触发条件</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        location /download/ &#123;</div><div class="line">            limit_conn addr 1;    // 限制同一时间内1个连接，超出的连接返回503</div><div class="line">                &#125;</div><div class="line">           &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="白名单设置"><a href="#白名单设置" class="headerlink" title="白名单设置"></a>白名单设置</h3><p>http_limit_conn和http_limit_req模块限制了单ip单位时间内的并发和请求数，但是如果Nginx前面有lvs或者haproxy之类的负载均衡或者反向代理，nginx获取的都是来自负载均衡的连接或请求，这时不应该限制负载均衡的连接和请求，就需要geo和map模块设置白名单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">geo $boohee &#123;</div><div class="line">   default 1;</div><div class="line">   127.0.0.1 0;</div><div class="line">   192.168.1.0/24 0;</div><div class="line">&#125;</div><div class="line">map $boohee $limit &#123;</div><div class="line">   1 $binary_remote_addr;</div><div class="line">   0 &quot;&quot;;</div><div class="line">&#125;</div><div class="line">limit_req_zone $limit zone=one:10m rate=20r/s;</div><div class="line">limit_conn_zone $limit zone=addr:10m;</div></pre></td></tr></table></figure></p>
<p>geo模块定义了一个默认值是1的变量boohee，当在ip在白名单中，变量boohee的值为0，反之为1</p>
<p>如果ip在白名单中，boohee=0，$limit=””，则不受到限制</p>
<p>如果ip不在白名单中，boohee=1，$limit=$binary_remote_addr，受到限制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/20/nginx/" data-id="ciu2e80fk000j7rhp5v0cxgf1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rsync" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/13/rsync/" class="article-date">
  <time datetime="2016-03-12T16:00:00.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/rsync/">rsync实现机制原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="为什么要使用rsync"><a href="#为什么要使用rsync" class="headerlink" title="为什么要使用rsync"></a>为什么要使用rsync</h3><p>在linux文件系统下面，我们通常使用scp来进行两台机器之间传输文件，大部分情况下，这是一个简单好用的方式。然而，对于大数据文件的拷贝，或者是文件的同步，使用scp就会出现问题，因为scp不支持断点续传。什么是断点续传，就是在拷贝文件的过程中，因为某些原因，同步失败了，如果使用scp，那么你得重新开始进行同步。这个时候，使用rsync，就方便多了。</p>
<h3 id="什么是rsync"><a href="#什么是rsync" class="headerlink" title="什么是rsync"></a>什么是rsync</h3><p>rsync（remote synchronize）是Liunx/Unix下的一个远程数据同步工具。它可通过LAN/WAN快速同步多台主机间的文件和目录，并适当利用rsync算法（差分编码）以减少数据的传输。rsync算法并不是每一次都整份传输，而是只传输两个文件的不同部分，因此其传输速度相当快。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>首先， 我们先来想一下rsync要解决的问题，如果我们要同步的文件只想传不同的部分，我们就需要对两边的文件做diff，但是这两个问题在两台不同的机器上， 无法做diff。如果我们做diff，就要把一个文件传到另一台机器上做diff，但这样一来，我们就传了整个文件，这与我们只想传输不同部的初衷相背。于是我们就要想一个办法，让这两边的文件见不到面，但还能知道它们间有什么不同。这就出现了rsync的算法。<br><strong>分块Checksum算法</strong><br>假设我们同步源文件名为fileSrc，同步目的文件叫fileDst<br>首先，我们会把fileDst的文件平均切分成若干个小块，比如每块512个字节（最后一块会小于这个数），然后对每块计算两个checksum</p>
<ul>
<li>一个叫rolling checksum，是弱checksum，32位的checksum，其使用的是Mark Adler发明的adler-32算法，</li>
<li>另一个是强checksum，128位的，以前用md4，现在用md5 hash算法。</li>
</ul>
<p>为什么要这样？因为若干年前的硬件上跑md4的算法太慢了，所以，我们需要一个快算法来鉴别文件块的不同，但是弱的adler32算法碰撞概率太高了，所以我们还要引入强的checksum算法以保证两文件块是相同的。也就是说，弱的checksum是用来区别不同，而强的是用来确认相同。</p>
<p><strong>传输文件</strong><br>同步目标端会把fileDst的一个checksum列表传给同步源，这个列表里包括了三个东西，rolling checksum(32bits)，md5 checksume(128bits)，文件块编号。同步源机器拿到了这个列表后，会对fileSrc做同样的checksum，然后和fileDst的checksum做对比，这样就知道哪些文件块改变了。<br>然而，事情并没有那么简单</p>
<ul>
<li>如果我fileSrc这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和fileDst这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？</li>
<li>如果这个checksum列表特别长，而我的两边的相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？</li>
</ul>
<p><strong>checksum查找算法</strong><br>同步源端拿到fileDst的checksum数组后，会把这个数据存到一个 hash table中，用rolling checksum做hash，以便获得O(1)时间复杂度的查找性能。这个hash table是16bits的，所以，hash table的尺寸是2的16次方，对rolling checksum的hash会被散列到0 到 2^16 – 1中的某个整数值。</p>
<p><strong>比对算法</strong><br>这是最关键的部分<br>1、取fileSrc的第一个文件块（我们假设的是512个长度），也就是从fileSrc的第1个字节到第512个字节，取出来后做rolling checksum计算。计算好的值到hash表中查。<br>2、如果查到了，说明发现在fileDst中有潜在相同的文件块，于是就再比较 md5的checksum，因为rolling checksume太弱了，可能发生碰撞。于是还要算md5的128bits的checksum。如果rolling checksum和md5 checksum都相同，这说明在fileDst中有相同的块，我们需要记下这一块在fileDst下的文件编号。<br>3、如果fileSrc的rolling checksum 没有在hash table中找到，那就不用算md5 checksum了。表示这一块中有不同的信息。总之，只要rolling checksum 或 md5 checksum 其中有一个在fileDst的checksum hash表中找不到匹配项，那么就会触发算法对fileSrc的rolling动作。于是，算法会住后step 1个字节，取fileSrc中字节2-513的文件块要做checksum，重复第一步，所以我们叫做rolling checksum。<br>这样，我们就可以找出fileSrc相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。</p>
<p>上面的文字有些同学可能已经看晕了，下面这张是我在网上找的一张非常经典的图，很好的描述了上面的步骤。<br><img src="http://coolshell.cn/wp-content/uploads/2012/05/rsync-algorithm.jpg" alt="1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/13/rsync/" data-id="ciu2e80ga000q7rhpaeonpntw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mongodb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/06/mongodb/" class="article-date">
  <time datetime="2016-03-05T16:00:00.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/mongodb/">mongodb 在复制集上创建修改索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讲mongodb如何在复制集上创建或修改索引的操作步骤前，我们先来了解一下mongodb在创建索引时会产生什么影响。<br>mongodb在默认情况下，创建索引会阻塞数据库中所有其他操作。当在一个集合上创建索引时，存储了这个集合的数据库变成不可读不可写的状态直到索引建立完毕。任何需要所有数据库中读或者写锁的操作(例如 listDatabases )将会等待，直到索引创建完成。<br>对于可能需要长时间运行的索引创建操作，可以考虑 background 选项，这样MongoDB数据库在索引创建期间仍然是可用的。<br>例如，在 people 集合的 zipcode 键上创建一个索引，这个过程在后台运行，可以使用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.people.createIndex( &#123; zipcode: 1&#125;, &#123;background: true&#125; )</div></pre></td></tr></table></figure></p>
<p>默认地，MongoDB索引创建的 background 是 false 。索引在创建过程中,查询将不会使用部分建立的索引：索引只有在建立完毕之后才是可用的。</p>
<p><strong>tips：</strong><br>使用后台索引的方式，虽然可以保证数据库可用，但是会影响mongodb的性能，后台索引创建操作使用的是一种增量的方式，这会比普通的 “前台” 创建过程慢。如果索引大于现有的内存，那么这个增量处理过程将会比前台创建过程 久得多 。<br>如果MongoDB在后台创建一个索引，您不能执行其他会涉及到该集合的管理操作，包括 repairDatabase 命令，删除集合(例如 db.collection.drop() )，和 compact 命令。当后台创建索引时，这些操作会返回一个错误。<br>If your application includes createIndex() operations, and an index doesn’t exist for other operational concerns, building the index can have a severe impact on the performance of the database.<br>为了避免性能问题，请确保您的应用在启动时就使用 getIndexes() 方法或者其他 equivalent method for your driver 检查索引是否存在，如果不存在请退出应用。或者在生产实例上使用不同的应用代码在指定的维护时间窗口期间创建索引。</p>
<p>处于以上考虑，对于mongodb复制集的索引创建和修改，mongodb官方建议使用下面步骤</p>
<p><strong>停止一个从节点</strong><br>停止一个从节点上的 mongod 进程。重启 mongod 进程， 不要 带 –replSet 选项且指定一个不同的端口。限制这个实例是运行在 “standalone” 模式下的。</p>
<p><strong>创建索引</strong><br>在 mongo shell 里通过 ensureIndex() 方法创建新索引（mongodb3.2版本，“ensureIndex() ”方法已经停用，使用createIndex()方法来创建索引 ）<br>例如，为了在 records 集合的 username 键上创建一个递增索引，可以使用如下 mongo shell 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.records.createIndex( &#123; username: 1 &#125; )</div></pre></td></tr></table></figure></p>
<p><strong>重启 mongod 进程</strong><br>当索引创建完毕，在原有端口上用选项 –replSet 重启 mongod 实例，让其加入到复制集中，同步数据。</p>
<p><strong>在所有从节点上创建索引</strong><br>对于复制集中的每个从节点，按如下步骤创建索引：</p>
<p>停止一个从节点<br>创建索引<br>重启 mongod 进程</p>
<p><strong>主节点</strong><br>使用 mongo shell 中的 rs.stepDown() 方法让主节点下台(step down)，这样主节点平滑地过渡为从节点，且允许复制集选举其他成员为主节点。<br>然后重启上述索引创建步骤，在(原)主节点上创建索引:<br>停止一个从节点<br>创建索引<br>重启 mongod 进程<br>在后台创建索引会比前台方式耗时更久，且会生成不够紧凑的索引 结构。此外，后台创建索引可能会影响主节点的写性能。但是，在后台建立索引允许复制集在MongoDB建立索引期间持续写操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/06/mongodb/" data-id="ciu2e80fd000f7rhp4y9kekte" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ftp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/ftp/" class="article-date">
  <time datetime="2016-02-26T16:00:00.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/ftp/">记一次关于ftp使用的那些事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>FTP，是一个相当古老的文件传输协议之一，相比大家伙都不会陌生，它的主要功能是在服务器和客户端之间进行文件的传输。由于比较古老，在安全方面比较落后，所以在实际应用当中，一般都会使用vsftp这个软件。</p>
<p>今天我为什么要讲一讲这个大家都很熟悉的软件了，自然是我们也在使用它，并且和它也发生了那么些事。<br>关于如何安装和使用，我在这里就不具体详解了，网上资料一大把。今天我们主要来讲讲实际应用当中，遇到的那些事。</p>
<p>我把vsftp服务搭建好了之后，创建了虚拟用户，并使用TLS协议加密登录，在公司稳稳当当的使用了一段时间，后来断断续续有人来跟我说，vsftp连接不上去；这里注明一下，我们是使用filezilla客户端进行连接的。我跑到安装vsftp的服务器上面查看，发现虽然客户端那边断开了，但是还是有进程在，开始以为是客户端的问题，我把进程kill之后，就能正常连接了。但是后来，一直都有类似的问题出现，我把服务端这边的配置都重新清理了一遍，实在是找不到原因。直到有一次，ftp又出现不能连接的问题之后，我是用netstat查看ftp端口发现是close_wait状态，我仿佛像是抓到了救命稻草一样，发现了问题的所在，虽然我不知道这是什么意思，但我敢肯定，问题就在这。</p>
<p>首先我们知道，如果我们的服务器程序处于CLOSE_WAIT状态的话，说明套接字是被动关闭的！<br>因为如果是CLIENT端主动断掉当前连接的话，那么双方关闭这个TCP连接共需要四个packet：</p>
<p>Client –-&gt; FIN  –-&gt; Server<br>Client &lt;–- ACK  &lt;–- Server<br>这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。<br>Client &lt;–- FIN  &lt;–- Server<br>这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。<br>Client –-&gt; ACK  –-&gt; Server<br>Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态。</p>
<p>Server 程序处于CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，导致没有发这个FIN packet。<br>通常来说，一个CLOSE_WAIT会维持至少2个小时的时间（这个时间外网服务器通常会做调整，要不然太危险了）。如果有个流氓特地写了个程序，给你造成一堆的CLOSE_WAIT，消耗你的资源，那么通常是等不到释放那一刻，系统就已经解决崩溃了。<br>只能通过修改一下TCP/IP的参数，来缩短这个时间：修改tcp<em>keepalive</em>*系列参数有助于解决这个问题。<br>其实一个close_wait并不会导致ftp服务不可用，问题就在于我们是使用ftp被动连接模式，并且只对外打开了一个端口。如果产生了一个close_wait，那么相应的端口也被占用了，那么这个时候，其他人就连接不上去了，或者等两个小时之后等服务器自动断开。<br>解决方法，要么修改TCP/IP参数，这个比较麻烦，所以采用第二种方式，增加一个端口，由于是被动模式，我们是可以在配置文件里面定义对外的端口范围。我在原来的基础上增加了一个对外的端口，如果有一个端口处于close_wait状态，至少还有一个可以使用，果然到现在只出现过一次连接不上的问题了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/27/ftp/" data-id="ciu2e80f7000b7rhplru08by1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/21/docker-03/" class="article-date">
  <time datetime="2016-02-20T16:00:00.000Z" itemprop="datePublished">2016-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/21/docker-03/">Docker 入门系列之--镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇我们已经讲过了，docker容器的创建和管理；今天，我们来讲一讲docker镜像的创建，以及管理。<br>我们知道，容器是基于镜像生成的。那么，什么是docker镜像了？<br>根据docker官方文档的描叙，Image（镜像）是docker术语的一种，代表一个只读的layer。而layer则具体代表docker container文件系统中可叠加的部分。<br>被我这么一介绍，相信很多小伙伴们更加迷惑了，怎么又出来一个layer，什么叫做可叠加的文件系统。在解答这些疑惑之前，让我们来了解几个和docker镜像相关的几个概念：rootfs、union mount。</p>
<h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>rootfs：代表一个docker container在启动时其内部进程可见的文件系统视角，或者说是container的根目录。当然，该目录下面还有container需要的系统文件，容器文件等。<br>说到rootfs，相信大家不会陌生，因为在linux操作系统内核启动的时候，内核会先挂载一个只读的rootfs，然后在系统自检完成之后，将其改为read-write，这样我们就可以在rootfs上面进行读写操作了。但是docker镜像却不这样，它在bootfs自检完成之后，并不会把rootfs的read-only改成read-write，而是利用union mount（Union FS的一种挂在机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs上面。虽然加载多层的rootfs，但是在外面看来，仍像是一个文件系统。<code>在Docker体系里面，把union mount的这些read-only的rootfs叫做镜像</code> 细心的读者可能会问，此时的每一层rootfs都是read-only状态，如何进行写操作了。当我们创建容器的时候，也就是将docker镜像实例化的时候，系统再次使用union mount在一层或多层read-only的rootfs之上挂载一个read-write的文件系统，但是此时的read-write文件系统是一个空的文件系统。</p>
<h3 id="union-mount"><a href="#union-mount" class="headerlink" title="union mount"></a>union mount</h3><p> union mount 是一种文件系统的挂载方式，允许同一时刻多个不同的文件系统挂在在一起，并且以一种文件系统的形式，将多个文件系统的内容合并成一个目录。<br> 一般情况下面，通过一种文件系统挂在内容至挂载点，挂载点原先的内容会被覆盖掉。但是如果是union mount则不会将挂载点目录中的内容隐藏，反而是将挂载点目录中的内容和被挂载的内容合并，并为合并后的内容提供一个统一独立的文件系统视角。通常来讲，被合并的文件系统中只有一个会以读写（read-write）模式挂载，而其他的文件系统的挂载模式均为只读（read-only）。实现这种Union mount技术的文件系统一般被称为Union Filesystem，较为常见的有UnionFS、AUFS、OverlayFS等。<br> Aufs是Docker最初采用的文件系统，由于Aufs未能加入到Linux内核，考虑到兼容性问题，加入了Devicemapper的支持。目前，除少数版本如Ubuntu，Docker基本运行在Devicemapper基础上。</p>
<p>好了，关于概念性的就先介绍到这里。接下来，我们进入实战环节。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>我们在运行容器的时候，选择的镜像都是已经下载到本地了，如果你在启动容器的时候，选择的镜像本地没有，那么docker会先自动进行下载。本地存放的目录一般是在/var/lib/docker下面。</p>
<p><strong>列出本地镜像</strong><br>docker images<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker images</div><div class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</div><div class="line">ggyy/one                 latest              c4ff03bdb0d8        4 days ago          1.187 GB</div><div class="line">ggyy/ruby                2.1.5               f68ff1ea510c        5 days ago          946.4 MB</div><div class="line">daocloud.io/gyban/ruby   2.1.5               f68ff1ea510c        5 days ago          946.4 MB</div><div class="line">daocloud.io/mysql        5.7                 596847483ae2        3 weeks ago         360.2 MB</div><div class="line">daocloud.io/rails        onbuild             26e7aa58d0c5        9 weeks ago         772.1 MB</div><div class="line">daocloud.io/centos       6                   3bbbf0aca359        4 months ago        190.6 MB</div></pre></td></tr></table></figure></p>
<p>通过docker images可以看到镜像来至于哪个仓库，它的tag，镜像的UUID，创建时间和大小。<br>镜像是从仓库下载下来的，镜像是保存在仓库中，而仓库存在于Registy中。默认的Registry是由docker公司自己运营的<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>。一个仓库里面可以存放多个镜像，例如centos6.5和centos6.6都是存放在centos这个仓库里面，所以需要使用tag以示区分。我们可以在仓库名后面加上一个冒号和标签名来指定该仓库中的某一镜像，如果不指定，默认使用latest。<br>Docker Hub中有两种类型的仓库：用户仓库和顶层仓库。用户仓库的镜像都是由Docker用户创建的，而顶层仓库则是由Docker内部的人来管理的。用户仓库的命令由用户名和仓库名两部分组成。</p>
<p>下面两个例子，第一个没有指定tag，则使用默认的latest镜像启动容器，第二个指定了tag，则会使用centos6.5版本启动容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it centos /bin/bash</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it centos:6.5 /bin/bash</div></pre></td></tr></table></figure>
<p><strong>拉取镜像</strong><br>虽然在运行容器的时候，docker会自动下载镜像，但我们也可以提前将镜像拉取下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull centos</div></pre></td></tr></table></figure></p>
<p>上面这条命令会将整个centos仓库里面的镜像都拉取下来，如果只需要拉取某个镜像使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull centos:6.5</div></pre></td></tr></table></figure></p>
<p><strong>查找镜像</strong><br>如果你想知道某个应用在docker hub上面有没有标准镜像，你可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search nginx</div></pre></td></tr></table></figure></p>
<p><strong>构建镜像</strong><br>前面我们所使用的镜像，都是制作好了的，那么我们如何制作按照自己的需求来定制化一些镜像了。<br>构建Docker镜像有一下两种方法。</p>
<ul>
<li><p>使用docker commit 命令</p>
</li>
<li><p>使用docker build命令和Dockerfile文件</p>
</li>
</ul>
<p>我们先用这两种方式来构建一个镜像，然后我们再对比这两种方式的利和弊</p>
<p><strong><em>docker commit</em></strong><br>docker commit 有点类似于版本控制系统里面的提交变更。我们先创建一个容器，并在容器里面做出修改，你可以创建一个文件，或者安装一个软件，最后再将修改提交为一个新镜像。<br>首先我们先运行一个容器，并且touch一个文件abc.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it daocloud.io/centos:6 /bin/bash</div><div class="line">[root@a5886fb30e16 /]# touch abc.txt</div><div class="line">[root@a5886fb30e16 /]# ls</div><div class="line">abc.txt  dev  home  lib64       media  opt   root  sbin     srv  tmp  var</div><div class="line">bin      etc  lib   lost+found  mnt    proc  run   selinux  sys  usr</div><div class="line">[root@a5886fb30e16 /]#</div></pre></td></tr></table></figure></p>
<p>如果我们想保存当前状态，不想每次都创建abc.txt这个文件，我们需要使用exit命令从容器里面退出，之后使用docker commit命令进行提交。<br>操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@a5886fb30e16 /]# exit</div><div class="line">exit</div><div class="line">[root@gy-vm06 ~]# docker ps -l</div><div class="line">CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS                     PORTS               NAMES</div><div class="line">a5886fb30e16        daocloud.io/centos:6   &quot;/bin/bash&quot;         7 minutes ago       Exited (0) 7 seconds ago                       clever_swartz</div><div class="line">[root@gy-vm06 ~]# docker commit a5886fb30e16 gongyang/abc</div><div class="line">c1e704fc7820ede7b6e0a008e57be948486144d0d5d07bb784425880d0a1bcfb</div><div class="line">[root@gy-vm06 ~]#</div></pre></td></tr></table></figure></p>
<p>使用docker commit之前，首先使用docker ps  -l 获取刚刚运行的容器的信息，-l参数表示显示最后创建的一个容器信息。由于这个镜像是我个人创建的，所以是由用户名和仓库名来命名（gongyang/abc）。值得注意的是，docker commit提交的只是创建容器的镜像与容器当前状态之间有差异的部分（有兴趣的同学，可以使用docker save将原始镜像和commit之后的镜像进行对比），这使得该更新非常轻量。<br>然后我们使用docker images 查看刚刚创建的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker images</div><div class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</div><div class="line">gongyang/abc             latest              c1e704fc7820        14 minutes ago      190.6 MB</div><div class="line">ggyy/one                 latest              c4ff03bdb0d8        4 days ago          1.187 GB</div><div class="line">ggyy/ruby                2.1.5               f68ff1ea510c        6 days ago          946.4 MB</div><div class="line">daocloud.io/gyban/ruby   2.1.5               f68ff1ea510c        6 days ago          946.4 MB</div><div class="line">daocloud.io/mysql        5.7                 596847483ae2        3 weeks ago         360.2 MB</div><div class="line">daocloud.io/rails        onbuild             26e7aa58d0c5        9 weeks ago         772.1 MB</div><div class="line">daocloud.io/centos       6                   3bbbf0aca359        4 months ago        190.6 MB</div></pre></td></tr></table></figure></p>
<p>可以看到原始镜像daocloud.io/centos:6和创建后的镜像gongyang/abc大小是一样的，因为我只是touch了一个空文件。<br>接下来我们使用新镜像来运行一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it gongyang/abc /bin/bash</div><div class="line">[root@bc4a8a055ea0 /]# ls</div><div class="line">abc.txt  dev  home  lib64       media  opt   root  sbin     srv  tmp  var</div><div class="line">bin      etc  lib   lost+found  mnt    proc  run   selinux  sys  usr</div><div class="line">[root@bc4a8a055ea0 /]#</div></pre></td></tr></table></figure></p>
<p>可以看到，新运行的容器里面就有了abc.txt这个文件了，也就是说最开始容器的状态保存了下来。</p>
<p><strong><em>Dockerfile</em></strong><br>Docker公司并不推荐使用docker commit的方法来构建镜像。相反，推荐使用Dockerfile定义文件和docker build命令来构建镜像。Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像，之后使用docker build命令基于该Dockerfile中的指令构建一个新的镜像。<br>第一个Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# mkdir dockerfile</div><div class="line">[root@gy-vm06 ~]# cd dockerfile/</div><div class="line">[root@gy-vm06 dockerfile]# touch Dockerfile</div></pre></td></tr></table></figure></p>
<p>我们创建了一个dockerfile的目录来保存Dockerfile，这个目录就是我们的构建环境，Docker则称此环境为上下文或者构建上下文。Docker会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker守护进程。这样Docker守护进程就能直接访问你想在镜像中存储的任何代码、文件或者其他数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#version 0.0.1</div><div class="line">FROM daocloud.io/centos:6</div><div class="line">MAINTAINER gongyang@boohee.com</div><div class="line">RUN yum install -y nginx</div><div class="line">EXPOSE 80</div></pre></td></tr></table></figure></p>
<p>上面的Dockerfile由一系列的指令和参数组成。每条指令如FROM，都必须是大写字母，后面要跟一个参数：daocloud.io/centos:6。Dockerfile中的指令会按顺序从上倒下执行。<br>每条指令都会创建一个新的镜像层并对镜像进行提交。大体流程如下：</p>
<ul>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令，对容器做出修改。</li>
<li>执行类似docker commit的操作，提交一个新的镜像层。</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行Dockerfile中的下一条指令，直到所有指令都执行完毕。</li>
</ul>
<p><strong><em>Dockerfile常用指令</em></strong><br>除了上文中提到的RUN和EXPOSE。Dockerfile还提供更多其他指令。我们可以<br>在<a href="http://docs.docker.com/reference/builder查看关于Dockerfile全部指令的清单。" target="_blank" rel="external">http://docs.docker.com/reference/builder查看关于Dockerfile全部指令的清单。</a><br>1、CMD<br>CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。这个和使用docker run命令启动容器时指定运行的命令/bin/bash命令非常类似。但是这里需要大伙注意一点，使用docker run 命令可以覆盖CMD指令。如果我们在Dockerfile里指定了CMD指令，而同时在docker run 命令行中也指定了要运行的命令，命令行中指定的命令会覆盖Dockerfile中的CMD指令。<br>我们来看一个简单的例子：<br>我们使用docker history命令查看一个镜像的创建过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker history daocloud.io/centos:6 </div><div class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</div><div class="line">3bbbf0aca359        4 months ago        /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </div><div class="line">fea77d2fd61e        4 months ago        /bin/sh -c #(nop) LABEL License=GPLv2           0 B                 </div><div class="line">91e6f84b8fe8        4 months ago        /bin/sh -c #(nop) LABEL Vendor=CentOS           0 B                 </div><div class="line">2c2557968d48        4 months ago        /bin/sh -c #(nop) ADD file:c8f5f9054c3914e848   190.6 MB            </div><div class="line">47d44cb6f252        5 months ago        /bin/sh -c #(nop) MAINTAINER The CentOS Proje   0 B</div></pre></td></tr></table></figure></p>
<p>这是用Dockerfile build出来的一个镜像，其中有定义CMD命令为/bin/bash，也就是说，如果我们使用该镜像启动的容器，如果不指定运行的命令，就会默认使用CMD里面定义的命令。<br>下面的例子，我们虽然没有指定运行的命令，但我们还是进入到了改容器的bash交互界面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it daocloud.io/centos:6</div><div class="line">[root@3dc66dd7d1af /]#</div></pre></td></tr></table></figure></p>
<p>如果我们指定其它命令，则会覆盖CMD里面指定的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it daocloud.io/centos:6 /bin/ps</div><div class="line">  PID TTY          TIME CMD</div><div class="line">    1 ?        00:00:00 ps</div></pre></td></tr></table></figure></p>
<p><strong>tip：</strong><br>在Dockerfile中只能指定一条CMD指令。如果指定了多条CMD指令，也只有最后一条CMD指令会被使用。</p>
<p>2、ENTRYPOINT<br>ENTRYPOINT和CMD指令非常类似，主要区别在于，CMD指令可以被docker run命令行中命令所覆盖，而ENTRYPOINT指令提供的命令则不容易在启动容器时被覆盖。并且还可以接受docker run命令行中指定的参数。<br>其实，ENTRYPOINT指令指定的命令也是可以被覆盖的，在docker run命令行中加上–entrypoint标志覆盖ENTRYPOINT指令</p>
<p>3、WORKDIR<br>WORKDIR指令用来指定容器创建时的工作目录，CMD和ENTRYPOINT指定的程序会在这个目录下执行。<br>我们可以使用该指令为Dockerfile中后续的一系列指令设置工作目录，也可以为最终的容器设置工作目录。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WORKDIR /var/apps/one</div><div class="line">RUN gem install rails</div><div class="line">WORKDIR /usr/local/nginx/sbin</div><div class="line">RUN nginx</div></pre></td></tr></table></figure></p>
<p>上面例子中，首先将工作目录切换到/var/apps/one，安装rails，然后又将工作目录切换到/usr/local/nginx/sbin 启动nginx<br>我们也可以在docker run使用-w参数指定工作目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it -w /var/log daocloud.io/centos:6  pwd</div><div class="line">/var/log</div></pre></td></tr></table></figure></p>
<p>该参数会将容器内的工作目录设置为/var/log</p>
<p>4、ENV<br>ENV指令用来在镜像构建过程中设置环境变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV RVM_PATH /home/rvm/</div><div class="line">RUN gem install unicorn</div></pre></td></tr></table></figure></p>
<p>该指令会以下面的方式执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RVM_PATH=/home/rvm gem install unicorn</div></pre></td></tr></table></figure></p>
<p>我们也可以在其他指令中直接使用这些环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV RVM_PATH /home/rvm/</div><div class="line">WORKDIR $RVM_PATH</div></pre></td></tr></table></figure></p>
<p>这些环境变量会被持久保存到从我们镜像创建的任何容器中。<br>我们也可以在docker run命令行中使用-e来指定环境变量，不过这些变量将只会在运行时有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@gy-vm06 ~]# docker run -it -e &quot;WEB_PORT=9999&quot; daocloud.io/centos:6  env</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</div><div class="line">HOSTNAME=b9d880f3e7e5</div><div class="line">TERM=xterm</div><div class="line">WEB_PORT=9999</div><div class="line">HOME=/root</div></pre></td></tr></table></figure></p>
<p>我么可以看到WEB_PORT环境变量被设为了9999</p>
<p>5、USER<br>USER指令用来指定该镜像启动的容器会以哪个用户运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">USER nginx</div></pre></td></tr></table></figure></p>
<p>上面的指令表示，基于该镜像启动的容器会以nginx用户的身份来运行。我们还可以指定组名<br>也可以在docker run命令中通过-u选项来覆盖该指令指定的值，如果不通过USER指令指定用户，默认用户为root</p>
<p>6、VOLUME<br>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷是可以存在于一个或者多个容器内的特定目录，这个目录可以绕过联合文件系统，并提供一下共享数据或者对数据进行持久化的功能。</p>
<ul>
<li>卷可以在容器间共享和复用</li>
<li>一个容器可以不是必须和其他容器共享卷</li>
<li>对卷的修改即时生效</li>
<li>对卷的修改不会对更新镜像产生影响</li>
<li>卷会一直存在直到没有任何容器再使用它</li>
</ul>
<p>卷功能让我们可以将数据、数据库元数据或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容。我们可以利用此功能来测试容器和内部的应用程序代码，管理日志，或者处理容器内部的数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VOLUME [&quot;/data&quot;]</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VOLUME [&quot;/data&quot;,&quot;/var/lib/mysql&quot;]</div></pre></td></tr></table></figure>
<p>我们也可以在docker run命令行中使用-v参数进行指定。</p>
<p>7、ADD<br>ADD 指令用来将构建环境下的文件和目录复制到镜像中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ADD nginx.conf /usr/local/nginx/conf/nginx.conf</div></pre></td></tr></table></figure></p>
<p>这里ADD会将构建目录下的nginx.conf文件复制到镜像中/usr/local/nginx/conf/nginx.conf。其中源文件的位置参数可以是一个URL，或者构建上下文的文件名或目录。不能对构建目录或者上下文之外的文件进行ADD操作。<br>在ADD文件时，docker通过目的地址参数末尾的字符来判断文件源是目录还是文件。如果目标地址是以/结尾，那么docker就认为源位置指向的是一个目录。如果不是，那么docker就认为源位置指向的是文件。如果目标地址不存在的话，docker将会为我们创建这个全路径，包括路径中的任何目录。新创建的文件和目录的模式为0755，并且GID和UID都是0。<br>ADD指令会使得构建缓存变得无效。如果通过ADD指令向镜像添加一个文件或者目录，那么这将使Dockerfile中的后续指令都不能继续使用之前的构建缓存。<br>最后ADD在处理归档文件时，会自动进行解压。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ADD test.tar.gz  /var/local/test/</div></pre></td></tr></table></figure></p>
<p>上面的指令，会将test.tar.gz解压到/var/local/test/目录下面。</p>
<p>以上就是对docker镜像的入门讲解，更多的实战内容，会在后续的博客中体现出来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/21/docker-03/" data-id="ciu2e80f300097rhp2nwdax8g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/25/php-cgi/">使用Spawn-FCGI管理php-cgi</a>
          </li>
        
          <li>
            <a href="/2016/09/17/ngxtop/">ngxtop---nginx日志实时监控工具</a>
          </li>
        
          <li>
            <a href="/2016/09/04/conntrack/">系统内核参数--nf_conntrack</a>
          </li>
        
          <li>
            <a href="/2016/08/28/tmpwatch/">tmpwatch</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>